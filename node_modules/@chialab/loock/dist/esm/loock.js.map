{
  "version": 3,
  "sources": ["../../src/Manager.js", "../../src/Context.js", "../../src/keys.js", "../../src/mixin.js", "../../src/index.js"],
  "sourcesContent": ["import { window, document } from '@chialab/dna';\nimport { Context } from './Context.js';\nimport { ESC_KEY, TAB_KEY } from './keys.js';\n\n/**\n * Interval between keydown triggers.\n */\nconst TIME_BETWEEN_KEYDOWNS = 150;\n\n/**\n * A manager for Loock contexts.\n */\nexport class Manager {\n    /**\n     * Create a new Loock instance.\n     * @param {Window} root\n     */\n    constructor(root = window) {\n        /**\n         * @readonly\n         */\n        this.root = root;\n\n        /**\n         * @protected\n         * @type {Context[]}\n         */\n        this.contexts = [];\n\n        /**\n         * @protected\n         * @type {Context[]}\n         */\n        this.actives = [];\n\n        /**\n         * @protected\n         * @type {Context}\n         */\n        this.defaultContext = undefined;\n\n        /**\n         * @protected\n         * @type {Context}\n         */\n        this.activeContext = undefined;\n\n        /**\n         * @private\n         * @type {HTMLElement}\n         */\n        this._activeElement = undefined;\n\n        /**\n         * @private\n         * @type {WeakMap<Context, { onFocusEnter: (event: Event) => void; onFocusExit: (event: Event) => void; }>}\n         */\n        this._listeners = new WeakMap();\n\n        /**\n         * @private\n         */\n        this.onKeyDown = async (event) => {\n            if (!this.activeContext) {\n                return;\n            }\n            if (event.key == ESC_KEY.key || event.key == ESC_KEY.altKey) {\n                if (this.activeContext === this.defaultContext) {\n                    if (this.activeContext.hasCurrentElement()) {\n                        event.preventDefault();\n                        this.activeContext.unsetCurrentElement();\n                    }\n                    return;\n                }\n                event.preventDefault();\n                const result = await this.activeContext.exit();\n                if (!result) {\n                    return;\n                }\n            } else if (event.keyCode == TAB_KEY.keyCode) {\n                event.preventDefault();\n                // prevent compulsively key holding down in all browsers.\n                if ((Date.now() - this._lastKeydownTime) < TIME_BETWEEN_KEYDOWNS) {\n                    return;\n                }\n                this._lastKeydownTime = Date.now();\n                const elements = this.activeContext.findFocusableChildren();\n                if (elements.length === 0) {\n                    const result = await this.activeContext.exit();\n                    if (!result) {\n                        return;\n                    }\n                }\n                if (event.shiftKey) {\n                    this.activeContext.prev();\n                } else {\n                    this.activeContext.next();\n                }\n            }\n        };\n\n        /**\n         * @private\n         */\n        this.onFocusIn = ({ target }) => {\n            const context = this.contexts\n                .filter((context) => !context.disabled)\n                .filter(({ element }) => element === target || element.contains(target))\n                .sort(({ element: match1 }, { element: match2 }) => (match1.contains(match2) ? 1 : -1))[0];\n\n            if (context) {\n                if (!context.active) {\n                    context.enter(target);\n                } else if (target !== context.element) {\n                    context.setCurrentElement(target);\n                } else {\n                    context.unsetCurrentElement(false);\n                }\n            } else if (this.activeContext) {\n                this.activeContext.exit();\n            }\n        };\n\n        /**\n         * @private\n         */\n        this.onIframeFocus = () => {\n            setTimeout(() => {\n                if (document.activeElement?.tagName === 'IFRAME') {\n                    if (this.activeContext) {\n                        this.activeContext.exit();\n                    }\n                }\n            }, 0);\n        };\n\n        root.addEventListener('keydown', this.onKeyDown);\n        root.addEventListener('focusin', this.onFocusIn);\n        root.addEventListener('focusout', this.onIframeFocus);\n    }\n\n    /**\n     * Create a default context.\n     *\n     * @param {HTMLElement} element The root of the default context.\n     * @param {import('./Context.js').ContextOptions} options A set of options for the context.\n     * @returns {Context} New context\n     */\n    createDefaultContext(element, options = {}) {\n        const context = this.defaultContext = this.createContext(element, options);\n        if (!context.disabled) {\n            context.enter();\n        }\n        return this.defaultContext;\n    }\n\n    /**\n     * Create a new context.\n     *\n     * @param {HTMLElement} element The root element of the context.\n     * @param {import('./Context.js').ContextOptions} options A set of options for the context.\n     * @returns {Context} New context\n     */\n    createContext(element, options = {}) {\n        const context = new Context(element, options);\n        this.addContext(context);\n        return context;\n    }\n\n    /**\n     * Handle a context.\n     * @param {Context} context The context to handle.\n     */\n    addContext(context) {\n        const io = this.contexts.indexOf(context);\n        if (io !== -1) {\n            return;\n        }\n        this.contexts.push(context);\n        context.attach(this);\n        context.enable();\n        this._listenContext(context);\n    }\n\n    /**\n     * Listen context events.\n     * @private\n     * @param {Context} context The context to listen.\n     */\n    _listenContext(context) {\n        const onFocusEnter = (event) => {\n            if ((/** @type {CustomEvent} */ (event)).detail !== context) {\n                return;\n            }\n            if (this.contexts.indexOf(context) !== -1) {\n                this._activeElement = /** @type {HTMLElement} */ (this._activeElement || this.root.document.activeElement);\n                this.activeContext = context;\n                this.actives.push(context);\n            }\n        };\n\n        const onFocusExit = (event) => {\n            if ((/** @type {CustomEvent} */ (event)).detail !== context) {\n                return;\n            }\n\n            const isActiveContext = context === this.activeContext;\n            const io = this.actives.indexOf(context);\n            this.actives.splice(io, 1);\n\n            if (!isActiveContext) {\n                return;\n            }\n\n            if (this.actives.length) {\n                this.activeContext = this.actives[this.actives.length - 1];\n                this.activeContext.restore();\n                return;\n            }\n\n            if (this.defaultContext === this.activeContext) {\n                return;\n            }\n\n            delete this.activeContext;\n\n            if (this.defaultContext && !this.defaultContext.disabled) {\n                this.defaultContext.enter();\n                return;\n            }\n\n            if (this._activeElement) {\n                this._activeElement.focus();\n                delete this._activeElement;\n            }\n        };\n\n        this._listeners.set(context, {\n            onFocusEnter,\n            onFocusExit,\n        });\n        context.element.addEventListener('focusenter', onFocusEnter);\n        context.element.addEventListener('focusexit', onFocusExit);\n    }\n\n    /**\n     * Unlisten context events.\n     * @private\n     * @param {Context} context The context to unlisten.\n     */\n    _unlistenContext(context) {\n        const listeners = this._listeners.get(context);\n        if (listeners) {\n            context.element.removeEventListener('focusenter', listeners.onFocusEnter);\n            context.element.removeEventListener('focusexit', listeners.onFocusExit);\n            this._listeners.delete(context);\n        }\n    }\n\n    /**\n     * Unhandle a context.\n     * @param {Context} context The context to remove.\n     */\n    removeContext(context) {\n        const io = this.contexts.indexOf(context);\n        if (io === -1) {\n            return;\n        }\n        context.disable();\n        this.contexts.splice(io, 1);\n        this._unlistenContext(context);\n    }\n\n    /**\n     * Destroy the Lock primary context.\n     */\n    destroy() {\n        this.contexts.forEach((context) => {\n            this.removeContext(context);\n        });\n        this.root.removeEventListener('keydown', this.onKeyDown);\n        this.root.removeEventListener('focusin', this.onFocusIn);\n        this.root.removeEventListener('focusout', this.onIframeFocus);\n    }\n}\n\n/**\n * The window manager instance.\n */\nexport const windowManager = new Manager(window);\n", "import { dispatchAsyncEvent } from '@chialab/dna';\n\n/**\n * Default focusable selectors.\n */\nexport const DEFAULT_SELECTORS = [\n    'button',\n    'input',\n    'select',\n    'textarea',\n    '[contenteditable=\"\"]',\n    '[contenteditable=\"true\"]',\n    'a[href]',\n    '[tabindex]',\n    'summary',\n];\n\n/**\n * Default ignore selectors.\n */\nexport const DEFAULT_IGNORE_SELECTORS = [\n    'details:not([open]) *:not(summary)',\n];\n\n/**\n * Private symbol to store the context of an element.\n */\nconst SYM = typeof Symbol !== 'undefined' ? Symbol('loock') : '__look_symbol__';\n\n/**\n * @typedef {(context: Context) => boolean|Promise<boolean>} DismissFunction\n */\n\n/**\n * @typedef {Object} ContextOptions\n * @property {boolean} [initialize] Self initialize the context.\n * @property {string|string[]} [selectors] A list of focusable selectors.\n * @property {string|string[]} [ignore] A list of selectors to ignore.\n * @property {boolean|DismissFunction} [dismiss] A dismiss rule for the context.\n * @property {boolean} [disabled] Disabled state of the context.\n */\n\n/**\n * Store the context of the element.\n * @param {HTMLElement} element The root element of the context.\n * @param {Context} context The context.\n */\nexport function setContext(element, context) {\n    element[SYM] = context;\n}\n\n/**\n * Get the context of the element.\n * @param {HTMLElement} element The root element of the context.\n * @returns {Context} The context of the element.\n */\nexport function getContext(element) {\n    return element[SYM];\n}\n\n/**\n * Loock context class.\n * @property {Loock} parent The Loock instance to bound.\n * @property {boolean} isActive The context state.\n */\nexport class Context {\n    /**\n     * Active state of the context.\n     */\n    get active() {\n        return this._active;\n    }\n\n    /**\n     * Disabled state of the context.\n     */\n    get disabled() {\n        return this._disabled || !this.element.isConnected;\n    }\n\n    /**\n     * Create a new context.\n     * @param {HTMLElement} element The root element of the context.\n     * @param {ContextOptions} options A set of options for the context.\n     * @param {import('./Manager.js').Manager} [parent] A set of options for the context.\n     */\n    constructor(element, options = {}, parent) {\n        this.element = element;\n        setContext(element, this);\n\n        /**\n         * @protected\n         */\n        this.focusableSelectors = DEFAULT_SELECTORS;\n\n        /**\n         * @protected\n         */\n        this.ignoredSelectors = DEFAULT_IGNORE_SELECTORS;\n\n        /**\n         * @protected\n         * @type {boolean|DismissFunction}\n         */\n        this.dismiss = true;\n\n        /**\n         * @protected\n         */\n        this.parent = parent;\n\n        /**\n         * @private\n         */\n        this._active = false;\n\n        /**\n         * @private\n         */\n        this._currentElement = null;\n\n        /**\n         * @private\n         */\n        this._lastKeydownTime = Date.now();\n\n        /**\n         * @private\n         */\n        this._tabIndex = element.getAttribute('tabindex') || '0';\n\n        if (options.selectors) {\n            this.setFocusableSelectors(options.selectors);\n        }\n        if (options.ignore) {\n            this.setIgnoredSelectors(options.ignore);\n        }\n        if (options.dismiss != null) {\n            this.setDismiss(options.dismiss);\n        }\n\n        /**\n         * @private\n         */\n        this.onClick = (event) => {\n            if (this.disabled) {\n                return;\n            }\n            const elements = this.findFocusableChildren();\n            const activeElement = /** @type {HTMLElement} */ (this.parent.root.document.activeElement);\n            if (activeElement && elements.indexOf(activeElement) !== -1) {\n                return;\n            }\n            let target = event.target;\n            while (element.contains(target) || target === element) {\n                if (elements.indexOf(target) !== -1) {\n                    target.focus();\n                    break;\n                }\n                if (target === element) {\n                    element.focus();\n                    break;\n                }\n                target = target.parentNode;\n            }\n        };\n\n        if (options.initialize !== false) {\n            if (options.disabled) {\n                this.disable();\n            } else {\n                this.enable();\n            }\n        }\n    }\n\n    /**\n     * Set focusable selectors.\n     * @param {string|string[]} selectors The selectors to set.\n     */\n    setFocusableSelectors(selectors) {\n        if (Array.isArray(selectors)) {\n            this.focusableSelectors = selectors;\n        } else if (typeof selectors === 'string' && selectors) {\n            this.focusableSelectors = selectors.split(',');\n        } else {\n            throw new Error('invalid selectors list');\n        }\n    }\n\n    /**\n     * Set selectors for elements to ignore.\n     * @param {string|string[]} selectors The selectors to ignore,\n     */\n    setIgnoredSelectors(selectors) {\n        if (Array.isArray(selectors)) {\n            this.ignoredSelectors = selectors;\n        } else if (typeof selectors === 'string' && selectors) {\n            this.ignoredSelectors = selectors.split(',');\n        } else {\n            throw new Error('invalid selectors list');\n        }\n    }\n\n    /**\n     * Returns focusable children elements.\n     *\n     * @returns {HTMLElement[]} focusable children of root element.\n     */\n    findFocusableChildren() {\n        const focusable = this.element.querySelectorAll(\n            this.focusableSelectors.map((selector) => `${selector}:not([type=hidden]):not([tabindex=\"-1\"]):not([disabled]):not([aria-hidden]):not([display=none])`).join(', ')\n        );\n        const elements = [].slice.call(focusable);\n        const ignore = this.ignoredSelectors.length ? [].slice.call(this.element.querySelectorAll(this.ignoredSelectors.join(','))) : [];\n\n        return elements\n            .filter((elem) => !ignore.some((area) => elem === area || area.contains(elem)))\n            .filter((elem) => {\n                const { width, height } = elem.getBoundingClientRect();\n                return !!height && !!width;\n            });\n    }\n\n    /**\n     *\n     * @param {boolean|DismissFunction} dismiss\n     */\n    setDismiss(dismiss) {\n        this.dismiss = dismiss;\n    }\n\n    /**\n     * Active previous focusable element.\n     *\n     * @returns {void}\n     */\n    prev() {\n        if (this.disabled) {\n            return;\n        }\n        const children = this.findFocusableChildren();\n        if (!children.length) {\n            this.restore();\n            return;\n        }\n        let io = children.indexOf(this._currentElement);\n        if (io === 0) {\n            io = children.length - 1;\n        } else if (io !== -1) {\n            io = io - 1;\n        } else {\n            io = children.length - 1;\n        }\n        this.setCurrentElement(children[io]);\n    }\n\n    /**\n     * Active next focusable element.\n     *\n     * @returns {void}\n     */\n    next() {\n        if (this.disabled) {\n            return;\n        }\n        const children = this.findFocusableChildren();\n        if (!children.length) {\n            this.restore();\n            return;\n        }\n        let io = children.indexOf(this._currentElement);\n        if (io === children.length - 1) {\n            io = 0;\n        } else if (io !== -1) {\n            io = io + 1;\n        } else {\n            io = 0;\n        }\n        this.setCurrentElement(children[io]);\n    }\n\n    /**\n     * Entering the context.\n     * @param {HTMLElement} [target] The target element to focus.\n     * @returns {Promise<void>}\n     */\n    async enter(target) {\n        if (this.disabled || this.active) {\n            return;\n        }\n        const element = this.element;\n        this._active = true;\n        if (!element.hasAttribute('aria-label') &&\n            !element.hasAttribute('aria-labelledby') &&\n            !element.hasAttribute('aria-describedby')) {\n            // eslint-disable-next-line\n            console.warn('created a Context without aria-label', this);\n        }\n        await dispatchAsyncEvent(element, 'focusenter', this);\n        if (target !== this.element) {\n            const children = this.findFocusableChildren();\n            if (children.indexOf(target) !== -1) {\n                this.setCurrentElement(target, false);\n            }\n        }\n        this.restore();\n    }\n\n    /**\n     * Restore the focus on the last element.\n     * @returns {void}\n     */\n    restore() {\n        if (this.disabled) {\n            return;\n        }\n        if (this._currentElement) {\n            this._currentElement.focus();\n        } else {\n            this.element.focus();\n        }\n    }\n\n    /**\n     * Exit from the context.\n     *\n     * @returns {Promise<boolean>}\n     */\n    async exit() {\n        if (this.disabled) {\n            return false;\n        }\n        if (!this.active) {\n            return false;\n        }\n        if (this.dismiss === false) {\n            return false;\n        }\n        if (typeof this.dismiss === 'function') {\n            const result = await this.dismiss(this);\n            if (result === false) {\n                return false;\n            }\n        }\n        await this.forceExit();\n        return true;\n    }\n\n    /**\n     * Force exit from the context.\n     *\n     * @returns {Promise<void>}\n     */\n    async forceExit() {\n        if (this.disabled) {\n            return;\n        }\n        this._active = false;\n        this.unsetCurrentElement(false);\n        await dispatchAsyncEvent(this.element, 'focusexit', this);\n    }\n\n    /**\n     * Set the current element of the context.\n     * @param {HTMLElement} element\n     * @param {boolean} focus Should focus the element.\n     */\n    setCurrentElement(element, focus = true) {\n        this._currentElement = element;\n        if (focus) {\n            element.focus();\n        }\n    }\n\n    /**\n     * Unset the current element of the context.\n     * @param {boolean} restore Should restore focus to container element.\n     */\n    unsetCurrentElement(restore = true) {\n        this._currentElement = null;\n        if (restore) {\n            this.restore();\n        }\n    }\n\n    /**\n     * Check if the context has a focused child.\n     *\n     * @returns {boolean}\n     */\n    hasCurrentElement() {\n        return this._currentElement !== null;\n    }\n\n    /**\n     * Attach the context to a Loock instance.\n     * @param {import('./Manager.js').Manager} parent The parent loock instance.\n     */\n    attach(parent) {\n        if (this.parent && this.parent !== parent) {\n            this.detach();\n        }\n        this.parent = parent;\n    }\n\n    /**\n     * Detach the context from the current Loock instance.\n     */\n    detach() {\n        this.forceExit();\n        this.parent.removeContext(this);\n        this.parent = null;\n    }\n\n    /**\n     * Enable the context that has been disabled.\n     */\n    enable() {\n        if (this._disabled === false) {\n            return;\n        }\n\n        this._disabled = false;\n        this.element.setAttribute('tabindex', this._tabIndex);\n        this.element.addEventListener('click', this.onClick);\n    }\n\n    /**\n     * Disable the context.\n     */\n    disable() {\n        if (this._disabled) {\n            return;\n        }\n\n        this.forceExit();\n        this._disabled = true;\n        this.element.setAttribute('tabindex', '-1');\n        this.element.removeEventListener('click', this.onClick);\n    }\n}\n", "/**\n * The tab key descriptor.\n */\nexport const TAB_KEY = {\n    key: 'Tab',\n    keyCode: '9',\n};\n\n/**\n * The esc key descriptor.\n */\nexport const ESC_KEY = {\n    key: 'Escape',\n    altKey: 'Esc',\n    keyCode: '27',\n};\n", "import { Context } from './Context.js';\nimport { windowManager } from './Manager.js';\n\n/**\n * @typedef {{ context: Context; onFocusEnter(): void; onFocusExit(): void; onFocusDismiss(): ReturnType<import('./Context.js').DismissFunction> }} FocusTrapMixin\n */\n\n/**\n * Enable focus trap context for components.\n * @template {import('@chialab/dna').ComponentInstance} T\n * @param {import('@chialab/dna').ComponentConstructor<T>} superClass The base component class.\n * @param {import('./Context.js').ContextOptions} [options] Focus trap options.\n * @returns An extended constructor.\n */\nexport const focusTrapMixin = (superClass, options) => {\n    const FocusTrapElement = class FocusTrapElement extends (/** @type {import('@chialab/dna').ComponentConstructor} */ (superClass)) {\n        /**\n         * @inheritdoc\n         */\n        constructor(...args) {\n            super(...args);\n            /**\n             * The keyboard navigation context.\n             * @readonly\n             */\n            this.context = new Context(this, {\n                dismiss: this.onFocusDismiss.bind(this),\n                ...options,\n                initialize: false,\n            });\n            this.addEventListener('focusenter', (event) => {\n                if (event.target === this) {\n                    this.onFocusEnter();\n                }\n            });\n            this.addEventListener('focusexit', (event) => {\n                if (event.target === this) {\n                    this.onFocusExit();\n                }\n            });\n        }\n\n        /**\n         * @inheritdoc\n         */\n        connectedCallback() {\n            super.connectedCallback();\n            windowManager.removeContext(this.context);\n            this.context.enable();\n            windowManager.addContext(this.context);\n        }\n\n        /**\n         * @inheritdoc\n         */\n        disconnectedCallback() {\n            super.disconnectedCallback();\n            windowManager.removeContext(this.context);\n        }\n\n        /**\n         * Callback invoked on focus enter.\n         */\n        onFocusEnter() { }\n\n        /**\n         * Callback invoked on focus exit.\n         */\n        onFocusExit() { }\n\n        /**\n         * Callback invoked on focus dismiss.\n         * @returns {ReturnType<import('./Context.js').DismissFunction>}\n         */\n        onFocusDismiss() {\n            return true;\n        }\n    };\n\n    return /** @type {import('@chialab/dna').ComponentConstructor<T & FocusTrapMixin>} */ (/** @type {unknown} */(FocusTrapElement));\n};\n", "import { Manager } from './Manager.js';\n\nexport * from './keys.js';\nexport * from './Context.js';\nexport * from './Manager.js';\nexport * from './mixin.js';\n\nexport const Loock = Manager;\n"],
  "mappings": "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",
  "names": ["window", "document", "dispatchAsyncEvent", "DEFAULT_SELECTORS", "DEFAULT_IGNORE_SELECTORS", "SYM", "setContext", "element", "context", "getContext", "Context", "options", "parent", "event", "elements", "activeElement", "target", "selectors", "focusable", "selector", "ignore", "elem", "area", "width", "height", "dismiss", "children", "io", "focus", "restore", "TAB_KEY", "ESC_KEY", "TIME_BETWEEN_KEYDOWNS", "Manager", "root", "window", "event", "ESC_KEY", "TAB_KEY", "target", "context", "element", "match1", "match2", "document", "options", "Context", "onFocusEnter", "onFocusExit", "isActiveContext", "io", "listeners", "windowManager", "focusTrapMixin", "superClass", "options", "args", "Context", "event", "windowManager", "Loock", "Manager"]
}
