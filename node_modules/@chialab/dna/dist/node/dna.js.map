{
  "version": 3,
  "sources": ["../../src/window.ts", "../../src/helpers.ts", "../../src/property.ts", "../../src/Context.ts", "../../src/DOM.ts", "../../src/events.ts", "../../node_modules/htm/dist/htm.mjs", "../../src/JSX.ts", "../../src/Thenable.ts", "../../src/Observable.ts", "../../src/css.ts", "../../src/render.ts", "../../src/directives.ts", "../../src/Component.ts", "../../src/CustomElementRegistry.ts"],
  "sourcesContent": ["import jsdom from 'jsdom';\n\nexport type GlobalNamespace = Window & typeof globalThis & {\n    _jsdom?: jsdom.JSDOM;\n};\n\nlet namespace: GlobalNamespace;\nif (typeof window !== 'undefined') {\n    /* eslint-env browser */\n    namespace = window;\n} else if (typeof global !== 'undefined') {\n    /* eslint-env node */\n    const jsd = new jsdom.JSDOM();\n    namespace = jsd.window as unknown as GlobalNamespace;\n    namespace._jsdom = jsd;\n} else {\n    // \u00AF\\_(\u30C4)_/\u00AF\n    const throwPlatform = function() {\n        throw new Error('Missing DOM implementation.');\n    };\n    namespace = {\n        Node: throwPlatform,\n        HTMLElement: throwPlatform,\n        Event: throwPlatform,\n        CustomEvent: throwPlatform,\n        document: {\n            createDocumentFragment: throwPlatform,\n            createElement: throwPlatform,\n            createElementNS: throwPlatform,\n            createTextNode: throwPlatform,\n            createComment: throwPlatform,\n            addEventListener() { },\n        },\n    } as unknown as GlobalNamespace;\n}\n\nexport { namespace as window };\n", "import { window } from './window';\n\n/**\n * Decorator class element descriptor.\n */\nexport interface ClassElement {\n    /**\n     * The kind of the class element.\n     */\n    kind: 'field' | 'method';\n    /**\n     * The name of the element.\n     */\n    key: PropertyKey;\n    /**\n     * The type of the element.\n     */\n    placement: 'static' | 'prototype' | 'own';\n    /**\n     * An initializer function.\n     */\n    initializer?: Function;\n    /**\n     * The element property descriptor.\n     */\n    descriptor?: PropertyDescriptor;\n    /**\n     * The descriptor finisher method.\n     */\n    finisher?: (constructor: Function) => void;\n}\n\n/**\n * The class descriptor interface.\n */\nexport type ClassDescriptor = {\n    kind: 'class';\n    elements: ClassElement[];\n    finisher?: <T>(constructor: { new(): T }) => void | { new(): T };\n};\n\n/**\n * Constructor type helper.\n */\nexport type Constructor<T> = {\n    new(...args: any[]): T;\n    prototype: T;\n};\n\nexport const {\n    Node: NodeConstructor,\n    HTMLElement: HTMLElementConstructor,\n    Event: EventConstructor,\n    CustomEvent: CustomEventConstructor,\n    document,\n} = window;\n\nexport const { DOCUMENT_NODE, TEXT_NODE, COMMENT_NODE, ELEMENT_NODE } = NodeConstructor;\n\n/**\n * Alias to Array.isArray.\n */\nexport const isArray = Array.isArray;\n\n/**\n * Alias to Object.getOwnPropertyDescriptor.\n */\nexport const getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n\n/**\n * Like Object.getOwnPropertyDescriptor, but for all the property chain.\n * @param object The object to get the descriptor from.\n * @param propertyKey The property key.\n * @returns A prototyped property descriptor.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const getPropertyDescriptor = (object: any, propertyKey: PropertyKey): PropertyDescriptor | undefined => {\n    if (!object) {\n        return;\n    }\n    return getOwnPropertyDescriptor(object, propertyKey) || getPropertyDescriptor(getPrototypeOf(object), propertyKey);\n};\n\n/**\n * Alias to Object.setPrototypeOf.\n */\nexport const getPrototypeOf = Object.getPrototypeOf;\n\n/**\n * Alias to Object.setPrototypeOf.\n * @param object The object to set the prototype of.\n * @param prototype The prototype to set.\n */\nexport const setPrototypeOf = Object.setPrototypeOf || ((object, prototype) => { object.__proto__ = prototype; });\n\n/**\n * Alias to Object.prototype.toString.\n */\nexport const toString = Object.prototype.toString;\n\n/**\n * Alias to Object.prototype.hasOwnProperty.\n */\nexport const hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Alias to Object.defineProperty.\n */\nexport const defineProperty = Object.defineProperty;\n\n/**\n * Alias to Node.prototype.appendChild.\n */\nexport const appendChildImpl = NodeConstructor.prototype.appendChild;\n\n/**\n * Alias to Node.prototype.removeChild.\n */\nexport const removeChildImpl = NodeConstructor.prototype.removeChild;\n\n/**\n * Alias to Node.prototype.insertBefore.\n */\nexport const insertBeforeImpl = NodeConstructor.prototype.insertBefore;\n\n/**\n * Alias to Node.prototype.replaceChild.\n */\nexport const replaceChildImpl = NodeConstructor.prototype.replaceChild;\n\n/**\n * Alias to HTMLElement.prototype.insertAdjacentElement.\n */\nexport const insertAdjacentElementImpl = HTMLElementConstructor.prototype.insertAdjacentElement;\n\n/**\n * Alias to Node.prototype.isConnected.\n */\nexport const isConnectedImpl = getOwnPropertyDescriptor(NodeConstructor.prototype, 'isConnected');\n\n/**\n * Alias to HTMLElement.prototype.getAttribute.\n */\nexport const getAttributeImpl = HTMLElementConstructor.prototype.getAttribute;\n\n/**\n * Alias to HTMLElement.prototype.hasAttribute.\n */\nexport const hasAttributeImpl = HTMLElementConstructor.prototype.hasAttribute;\n\n/**\n * Alias to HTMLElement.prototype.setAttribute.\n */\nexport const setAttributeImpl = HTMLElementConstructor.prototype.setAttribute;\n\n/**\n * Alias to HTMLElement.prototype.removeAttribute.\n */\nexport const removeAttributeImpl = HTMLElementConstructor.prototype.removeAttribute;\n\n/**\n * Alias to HTMLElement.prototype.matches.\n */\nexport const matchesImpl = HTMLElementConstructor.prototype.matches ||\n    HTMLElementConstructor.prototype.webkitMatchesSelector ||\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (HTMLElementConstructor.prototype as any).msMatchesSelector;\n\n/**\n * Alias to document.createDocumentFragment.\n */\nexport const createDocumentFragmentImpl = document.createDocumentFragment.bind(document);\n\n/**\n * Alias to document.createElement.\n */\nexport const createElementImpl = document.createElement.bind(document);\n\n/**\n * Alias to document.createElementNS.\n */\nexport const createElementNSImpl = document.createElementNS.bind(document);\n\n/**\n * Alias to document.createTextNode.\n */\nexport const createTextNodeImpl = document.createTextNode.bind(document);\n\n/**\n * Alias to document.createComment.\n */\nexport const createCommentImpl = document.createComment.bind(document);\n\n/**\n * Create a Custom Event.\n * @param typeArg The name of the event.\n * @param eventInitDict The options of the event.\n * @returns The constructed Custom Event.\n */\nexport const createEventImpl = (typeArg: string, eventInitDict: CustomEventInit<unknown> = {}): CustomEvent<unknown> => {\n    let event;\n    try {\n        event = new CustomEventConstructor(typeArg, eventInitDict);\n    } catch {\n        event = document.createEvent('CustomEvent');\n        event.initCustomEvent(typeArg, eventInitDict.bubbles || false, eventInitDict.cancelable || false, eventInitDict.detail);\n    }\n    return event;\n};\n\n/**\n * Check if the target is a Node instance.\n * @param target The target to check.\n * @returns The target is a Node instance.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isNode = (target: any): target is Node => target instanceof NodeConstructor;\n\n/**\n * Check if a node is a Document instance.\n * @param node The node to check.\n * @returns The node is a Document instance.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isDocument = (node: any): node is Document => node && node.nodeType === DOCUMENT_NODE;\n\n/**\n * Check if a node is a Text instance.\n * @param node The node to check.\n * @returns The node is a Text instance.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isText = (node: any): node is Text => node && node.nodeType === TEXT_NODE;\n\n/**\n * Check if a node is an Element instance.\n * @param node The node to check.\n * @returns The node is an Element instance.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isElement = <T extends Element>(node: any): node is T => node && node.nodeType === ELEMENT_NODE;\n\n/**\n * Check if an object is an Event instance.\n * @param event The target to check.\n * @returns The object is an Event instance.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isEvent = (event: any): event is Event => event instanceof EventConstructor;\n\n/**\n * Check if a Node is connected.\n * @param this The Node to check.\n * @returns A truthy value for connected targets.\n */\nexport const isConnected: (this: Node) => boolean = isConnectedImpl ?\n    (isConnectedImpl.get as (this: Node) => boolean) :\n    function(this: Node): boolean {\n        if (isElement(this) || isText(this)) {\n            const parent = this.parentNode;\n            if (!parent) {\n                return false;\n            }\n            return isConnected.call(parent);\n        }\n        if (isDocument(this)) {\n            return true;\n        }\n\n        return false;\n    };\n\n/**\n * The native custom elements registry.\n */\nexport const nativeCustomElements = window.customElements;\n\n/**\n * Clone an array like instance.\n * @param arr The array to convert.\n * @returns A shallow clone of the array.\n */\nexport const cloneChildNodes = (arr: NodeList) => {\n    const result: Node[] = [];\n    for (let i = arr.length; i--; result.unshift(arr.item(i) as Node));\n    return result;\n};\n", "import type { ClassElement, Constructor } from './helpers';\nimport type { Members, ComponentConstructor, ComponentInstance, MethodsOf } from './Component';\nimport { HTMLElementConstructor, isArray, defineProperty as _defineProperty, getOwnPropertyDescriptor, hasOwnProperty, getPrototypeOf } from './helpers';\nimport { isComponent } from './Component';\n\n/**\n * A Symbol which contains all Property instances of a Component.\n */\nconst PROPERTIES_SYMBOL: unique symbol = Symbol();\n\n/**\n * A Symbol which contains all Property observers of a Component.\n */\nconst OBSERVERS_SYMBOL: unique symbol = Symbol();\n\n/**\n * Retrieve properties declarations of a Component.\n */\nexport type PropertiesOf<T extends ComponentInstance> = {\n    [P in keyof Members<T>]: Property<T, P>;\n};\n\n/**\n * Retrieve properties declarations of a Component.\n */\nexport type ObserversOf<T extends ComponentInstance> = {\n    [P in keyof PropertiesOf<T>]: PropertyObserver<T[P]>[];\n};\n\n/**\n * A prototype with properties.\n */\nexport type WithProperties<T extends ComponentInstance> = T & {\n    [PROPERTIES_SYMBOL]?: PropertiesOf<T>;\n};\n\n/**\n * A prototype with observers.\n */\nexport type WithObservers<T extends ComponentInstance> = T & {\n    [OBSERVERS_SYMBOL]?: ObserversOf<T>;\n};\n\n/**\n * The observer signature for properties.\n *\n * @param oldValue The previous value of the property.\n * @param newValue The current value of the property.\n */\nexport type PropertyObserver<TypeHint = unknown> = (oldValue: TypeHint | undefined, newValue: TypeHint, propertyKey: string) => void;\n\n/**\n * Convert constructor types to their normalised instance types.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype ConvertConstructorTypes<C extends Constructor<unknown>, T = InstanceType<C>> = T extends Number ? number : T extends String ? string : T extends Boolean ? boolean : T extends unknown[] ? any[] : T extends Object ? any : T;\n\n/**\n * A state property declaration.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type PropertyDeclaration<TypeConstructorHint extends Constructor<any> = Constructor<any>> = PropertyDescriptor & {\n    /**\n     * The property private symbol.\n     */\n    symbol?: symbol;\n    /**\n     * Flag state properties.\n     */\n    state?: boolean;\n    /**\n     * The property is bound to an attribute. Also specifies the attribute name if different from the property.\n     */\n    attribute?: boolean | string;\n    /**\n     * The event to fire on property change.\n     */\n    event?: true | string;\n    /**\n     * Property change should trigger component update.\n     */\n    update?: boolean;\n    /**\n     * Convert attribute to property value.\n     *\n     * @param value The attributue value.\n     * @returns The property value.\n     */\n    fromAttribute?: (value: string | null) => ConvertConstructorTypes<TypeConstructorHint> | undefined;\n    /**\n     * Convert property to attribute value.\n     * @param value The property value.\n     * @returns The attributue value.\n     */\n    toAttribute?: (value: ConvertConstructorTypes<TypeConstructorHint>) => string|null|undefined;\n    /**\n     * The initial value of the property.\n     */\n    defaultValue?: ConvertConstructorTypes<TypeConstructorHint>;\n     /**\n      * A list of valid property values prototypes.\n      */\n    type?: TypeConstructorHint | TypeConstructorHint[];\n    /**\n     * Define a property observable.\n     */\n    observe?: PropertyObserver<ConvertConstructorTypes<TypeConstructorHint>>;\n    /**\n     * A list of field observables.\n     */\n    observers?: PropertyObserver<ConvertConstructorTypes<TypeConstructorHint>>[];\n    /**\n     * A custom validation function for the property.\n     * Property assignement throws when this function returns falsy values.\n     */\n    validate?: (value: unknown) => boolean;\n    /**\n     * Native custom getter for the property.\n     */\n    get?: PropertyDescriptor['get'];\n    /**\n     * Native custom setter for the property.\n     */\n    set?: PropertyDescriptor['set'];\n    /**\n     * Define custom getter for the property.\n     * @param value The current property value.\n     */\n    getter?: (value?: ConvertConstructorTypes<TypeConstructorHint>) => ReturnType<NonNullable<PropertyDescriptor['get']>>;\n    /**\n     * Define a custom setter for the property.\n     * It runs before property validations.\n     * The returned value will be set to the property.\n     * @param newValue The value to set.\n     */\n    setter?: (newValue?: Parameters<NonNullable<PropertyDescriptor['set']>>[0]) => ConvertConstructorTypes<TypeConstructorHint>;\n    /**\n     * The initializer function.\n     */\n    initializer?: Function;\n};\n\n/**\n * Property configuration for properties accessor.\n */\nexport type PropertyConfig<TypeConstructorHint extends Constructor<unknown> = Constructor<unknown>> = PropertyDeclaration<TypeConstructorHint> | TypeConstructorHint | TypeConstructorHint[];\n\n/**\n * A property instance.\n */\nexport type Property<T extends ComponentInstance, P extends keyof Members<T>>= PropertyDescriptor & {\n    /**\n     * The property name of the field.\n     */\n    readonly name: P;\n    /**\n     * The property has been defined using static getter.\n     */\n    readonly static: boolean;\n    /**\n     * The property private symbol.\n     */\n    symbol: symbol;\n    /**\n     * Flag state properties.\n     */\n    state: boolean;\n    /**\n     * The bound attribute name.\n     */\n    attribute?: string;\n    /**\n     * The event to fire on property change.\n     */\n    event?: string;\n    /**\n     * Property change should trigger component update.\n     */\n    update?: boolean;\n    /**\n     * The initial value of the property.\n     */\n    defaultValue?: T[P];\n    /**\n     * A list of valid property values prototypes.\n     */\n    type: Constructor<T[P]>[];\n    /**\n     * Convert attribute to property value.\n     *\n     * @param value The attributue value.\n     * @returns The property value.\n     */\n    fromAttribute?: (value: string|null) => T[P];\n    /**\n     * Convert property to attribute value.\n     * @param value The property value.\n     * @returns The attributue value.\n     */\n    toAttribute?: (value: T[P]) => string|null|undefined;\n    /**\n     * A custom validation function for the property.\n     * Property assignement throws when this function returns falsy values.\n     */\n    validate?: (value: unknown) => boolean;\n    /**\n     * Native custom getter for the property.\n     */\n    get?: PropertyDescriptor['get'];\n     /**\n      * Native custom setter for the property.\n      */\n    set?: PropertyDescriptor['set'];\n    /**\n     * Define custom getter for the property.\n     * @param value The current property value.\n     */\n    getter?: (value?: T[P]) => ReturnType<NonNullable<PropertyDescriptor['get']>>;\n    /**\n     * Define a custom setter for the property.\n     * It runs before property validations.\n     * The returned value will be set to the property.\n     * @param newValue The value to set.\n     */\n    setter?: (newValue?: Parameters<NonNullable<PropertyDescriptor['set']>>[0]) => T[P];\n    /**\n     * The initializer function.\n     */\n    initializer?: Function;\n}\n\n/**\n * Retrieve all properties descriptors.\n * @param prototype The component prototype.\n * @param chain Should create inheritance chain of properties.\n * @returns A list of property descriptors.\n */\nexport const getProperties = <T extends ComponentInstance>(prototype: WithProperties<T>, chain = false) => {\n    const props = (prototype[PROPERTIES_SYMBOL] || {}) as PropertiesOf<T>;\n\n    if (chain && !hasOwnProperty.call(prototype, PROPERTIES_SYMBOL)) {\n        return prototype[PROPERTIES_SYMBOL] = {\n            __proto__: props,\n        } as unknown as PropertiesOf<T>;\n    }\n\n    return props;\n};\n\n/**\n * Retrieve property declaration.\n * @param prototype The component prototype.\n * @param propertyKey The name of the property.\n * @param failIfMissing Should throw an exception if the property is not defined.\n * @returns The property declaration.\n * @throws If the property is not defined and `failIfMissing` is `true`.\n */\nexport const getProperty = <T extends ComponentInstance, P extends keyof PropertiesOf<T>>(prototype: T, propertyKey: P, failIfMissing = false) => {\n    const property = getProperties(prototype)[propertyKey];\n    if (failIfMissing && !property) {\n        throw new Error(`Missing property ${String(propertyKey)}`);\n    }\n    return property;\n};\n\n/**\n * Get valid constructors for the property.\n * @param declaration The property declaration.\n * @returns A list of constructors.\n */\nconst extractTypes = <T extends ComponentInstance, P extends keyof PropertiesOf<T>>(declaration: PropertyDeclaration<Constructor<T[P]>>) => {\n    const type = declaration.type;\n    if (!type) {\n        return [];\n    }\n    if (isArray(type)) {\n        return type;\n    }\n\n    return [type];\n};\n\n/**\n * Define an observed property.\n * @param prototype The component prototype.\n * @param propertyKey The name of the property.\n * @param declaration The property descriptor.\n * @param symbolKey The symbol to use to store property value.\n * @param isStatic The property definition is static.\n * @returns The final descriptor.\n */\nexport const defineProperty = <T extends ComponentInstance, P extends keyof Members<T>>(prototype: WithProperties<T>, propertyKey: P, declaration: PropertyDeclaration<Constructor<T[P]>>, symbolKey: symbol, isStatic = false): PropertyDescriptor => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const symbol: unique symbol = symbolKey as any;\n    const hasAttribute = declaration.attribute || (declaration.attribute == null ? !declaration.state : false);\n    const declarations = getProperties(prototype, true);\n    const attribute = hasAttribute ?\n        (typeof declaration.attribute === 'string' ? declaration.attribute : propertyKey) :\n        undefined;\n    const event = declaration.event ?\n        (declaration.event === true ? `${String(propertyKey)}change` : declaration.event) :\n        undefined;\n    const state = !!declaration.state;\n    const type = extractTypes(declaration);\n    const update = typeof declaration.update === 'boolean' ? declaration.update : true;\n    const acceptsBoolean = type.indexOf(Boolean as unknown as Constructor<T[P]>) !== -1;\n    const acceptsNumber = type.indexOf(Number as unknown as Constructor<T[P]>) !== -1;\n    const acceptsString = type.indexOf(String as unknown as Constructor<T[P]>) !== -1;\n    const property = declarations[propertyKey] = {\n        fromAttribute(newValue) {\n            if (acceptsBoolean && (!newValue || newValue === attribute)) {\n                if (newValue !== 'false' && (newValue === '' || newValue === attribute)) {\n                    // if the attribute value is empty or it is equal to the attribute name consider it as a boolean\n                    return true;\n                }\n                return false;\n            }\n            if (newValue) {\n                if (acceptsNumber && !isNaN(newValue as unknown as number)) {\n                    return parseFloat(newValue);\n                }\n                if (!acceptsString) {\n                    try {\n                        return JSON.parse(newValue as string);\n                    } catch {\n                        //\n                    }\n                }\n            }\n            return newValue;\n        },\n        toAttribute(newValue: unknown) {\n            if (newValue == null || newValue === false) {\n                // a falsy value should remove the attribute\n                return null;\n            }\n            const valueType = typeof newValue;\n            if (valueType === 'object' ||\n                valueType === 'symbol' ||\n                valueType === 'function') {\n                // references should be ignored\n                return;\n            }\n            // if the value is `true` should set an empty attribute\n            if (newValue === true) {\n                return '';\n            }\n            // otherwise just set the value\n            return `${newValue}`;\n        },\n        ...declaration,\n        name: propertyKey,\n        symbol,\n        state,\n        type,\n        attribute,\n        event,\n        update,\n        static: isStatic,\n    } as Property<T, P>;\n\n    const { get, set, getter, setter } = property;\n\n    type E = T & { [symbol]: E[P] };\n\n    const validate = typeof property.validate === 'function' && property.validate;\n    const finalDescriptor: PropertyDescriptor = {\n        configurable: true,\n        enumerable: true,\n        get(this: E) {\n            let value = this[symbol];\n            if (get) {\n                value = get.call(this);\n            }\n            if (getter) {\n                value = getter.call(this, value);\n            }\n            return value;\n        },\n        set(this: E, newValue) {\n            if (!isComponent(this) || this.watchedProperties.indexOf(propertyKey) === -1) {\n                this[symbol] = newValue;\n                return;\n            }\n\n            const oldValue = this[symbol];\n            if (setter) {\n                newValue = setter.call(this, newValue);\n            }\n            if (set) {\n                set.call(this, newValue);\n                newValue = this[symbol];\n            }\n\n            if (oldValue === newValue) {\n                // no changes\n                return;\n            }\n\n            // if types or custom validator has been set, check the value validity\n            if (newValue != null && newValue !== false) {\n                let valid = true;\n                if (type.length) {\n                    // check if the value is an instanceof of at least one constructor\n                    valid = type.some((Type) => (newValue instanceof Type || (newValue.constructor === Type)));\n                }\n                if (valid && validate) {\n                    valid = validate.call(this, newValue);\n                }\n                if (!valid) {\n                    throw new TypeError(`Invalid \\`${String(newValue)}\\` value for \\`${String(propertyKey)}\\` property`);\n                }\n            }\n\n            this[symbol] = newValue;\n\n            const observers = getPropertyObservers(this as T, propertyKey);\n            for (let i = 0, len = observers.length; i < len; i++) {\n                observers[i].call(this, oldValue, newValue, propertyKey as string);\n            }\n\n            if (event) {\n                this.dispatchEvent(event, {\n                    newValue,\n                    oldValue,\n                });\n            }\n\n            // trigger changes\n            if (state) {\n                this.stateChangedCallback(propertyKey, oldValue, newValue);\n            } else {\n                this.propertyChangedCallback(propertyKey, oldValue, newValue);\n            }\n\n            if (update) {\n                this.forceUpdate();\n            }\n        },\n    };\n\n    _defineProperty(prototype, propertyKey, finalDescriptor);\n\n    const observers = [...(declaration.observers || [])];\n    if (declaration.observe) {\n        observers.unshift(declaration.observe);\n    }\n    observers.forEach((observer) => {\n        addObserver(prototype, propertyKey, observer as PropertyObserver<T[P]>);\n    });\n\n    return finalDescriptor;\n};\n\n/**\n * Define component constructor properties.\n * @param prototype The component prototype.\n */\nexport const defineProperties = <T extends ComponentInstance>(prototype: T) => {\n    const handled: { [key: string]: boolean } = {};\n    const constructor = prototype.constructor as ComponentConstructor<T>;\n    let ctr = constructor;\n    while (ctr && ctr !== HTMLElementConstructor) {\n        const propertiesDescriptor = getOwnPropertyDescriptor(ctr, 'properties');\n        if (propertiesDescriptor) {\n            const descriptorProperties = (propertiesDescriptor.get ? (propertiesDescriptor.get.call(constructor) || {}) : propertiesDescriptor.value) as {\n                [P in keyof Members<T>]: PropertyConfig<Constructor<T[P]>>;\n            };\n            for (const propertyKey in descriptorProperties) {\n                if (propertyKey in handled) {\n                    continue;\n                }\n                const config = descriptorProperties[propertyKey];\n                const declaration = (typeof config === 'function' || isArray(config) ? { type: config } : config) as PropertyDeclaration<Constructor<T[typeof propertyKey]>>;\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const symbol: unique symbol = (declaration.symbol as any) || Symbol(propertyKey as string);\n                defineProperty(\n                    prototype,\n                    propertyKey,\n                    declaration,\n                    symbol,\n                    true\n                );\n                handled[propertyKey] = true;\n            }\n        }\n\n        ctr = getPrototypeOf(ctr);\n    }\n};\n\n/**\n * Get the property bound to the attribute.\n * @param prototype The prototype of the Component.\n * @param attributeName The name of the bound attribute.\n * @returns The property declaration.\n */\nexport const getPropertyForAttribute = <T extends ComponentInstance>(prototype: T, attributeName: string) => {\n    const properties = getProperties(prototype);\n    for (const propertyKey in properties) {\n        const property = properties[propertyKey];\n        if (property.attribute === attributeName) {\n            return property;\n        }\n    }\n    return null;\n};\n\n/**\n * Reflect property value to attribute.\n *\n * @param element The node to update.\n * @param propertyName The name of the changed property.\n * @param newValue The new value for the property (undefined if removed).\n */\nexport const reflectPropertyToAttribute = <T extends ComponentInstance, P extends keyof PropertiesOf<T>>(element: T, propertyName: P, newValue: T[P]) => {\n    const property = getProperty(element, propertyName, true);\n    const { attribute, toAttribute } = property;\n    if (attribute && toAttribute) {\n        const value = toAttribute.call(element, newValue);\n        if (value === null) {\n            element.removeAttribute(attribute);\n        } else if (value !== undefined && value !== element.getAttribute(attribute)) {\n            element.setAttribute(attribute, value as string);\n        }\n    }\n};\n\n/**\n * Reflect attribute value to property.\n *\n * @param element The node to update.\n * @param attributeName The name of the changed attribute.\n * @param newValue The new value of the attribute (null if removed).\n */\nexport const reflectAttributeToProperty = <T extends ComponentInstance>(element: T, attributeName: string, newValue: string | null) => {\n    const property = getPropertyForAttribute(element, attributeName);\n    if (!property) {\n        return;\n    }\n\n    // update the Component Property value\n    const { name, attribute, fromAttribute } = property;\n    if (attribute && fromAttribute) {\n        element[name] = fromAttribute.call(element, newValue);\n    }\n};\n\n/**\n * Populate property declaration using its field descriptor.\n * @param declaration The declaration to update.\n * @param descriptor The field descriptor.\n * @param initializer The property initializer function.\n */\nconst assignFromDescriptor = (declaration: PropertyDeclaration, descriptor: PropertyDescriptor, initializer?: Function) => {\n    declaration.initializer = initializer;\n    declaration.get = descriptor.get;\n    declaration.set = descriptor.set;\n    if (!descriptor.get) {\n        declaration.defaultValue = descriptor.value;\n    }\n};\n\n/**\n * Add a property to a component prototype.\n * @param targetOrClassElement The component prototype.\n * @param declaration The property declaration.\n * @param propertyKey The property name.\n * @param descriptor The native property descriptor.\n * @returns The property descriptor.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const createProperty = <T extends ComponentInstance, P extends keyof Members<T>>(targetOrClassElement: T, declaration: PropertyDeclaration<Constructor<T[P]>>, propertyKey?: P, descriptor?: PropertyDeclaration<Constructor<T[P]>>): any => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const symbol: unique symbol = declaration.symbol || Symbol(propertyKey as string) as any;\n    if (propertyKey !== undefined) {\n        descriptor = descriptor || getOwnPropertyDescriptor(targetOrClassElement, propertyKey);\n        if (descriptor) {\n            assignFromDescriptor(declaration, descriptor, descriptor.initializer);\n        }\n        return defineProperty(targetOrClassElement as T, propertyKey, declaration, symbol);\n    }\n\n    // spec 2\n    const element = targetOrClassElement as unknown as ClassElement;\n    const key = String(element.key) as P;\n    type E = T & {\n        [symbol]: E[P];\n    };\n\n    if (element.kind !== 'field' || element.placement !== 'own') {\n        return element;\n    }\n\n    if (element.descriptor) {\n        assignFromDescriptor(declaration, element.descriptor, element.initializer);\n    }\n\n    return {\n        kind: element.kind,\n        key: symbol,\n        placement: element.placement,\n        descriptor: {\n            configurable: false,\n            writable: true,\n            enumerable: false,\n        },\n        initializer(this: E) {\n            return this[symbol];\n        },\n        finisher(constructor: Constructor<T>) {\n            defineProperty(constructor.prototype, key, declaration, symbol);\n        },\n    };\n};\n\n/**\n * Add a property observer to a component prototype.\n * @param targetOrClassElement The component prototype.\n * @param propertyKey The property name to watch.\n * @param methodKey The method name.\n * @returns The observer descriptor.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const createObserver = <T extends ComponentInstance, P extends keyof PropertiesOf<T>, M extends keyof Members<T>>(targetOrClassElement: T, propertyKey: P, methodKey?: M): any => {\n    if (methodKey !== undefined) {\n        addObserver(targetOrClassElement, propertyKey, targetOrClassElement[methodKey] as unknown as PropertyObserver<T[P]>);\n        return;\n    }\n\n    const element = targetOrClassElement as unknown as ClassElement;\n    if (!element.descriptor) {\n        return element;\n    }\n    const observer = element.descriptor.value as PropertyObserver<T[P]>;\n    element.finisher = (constructor) => {\n        addObserver(constructor.prototype, propertyKey, observer);\n    };\n    return element;\n};\n\n/**\n * Get element properties observers.\n * @param element The node.\n * @returns The map of observers.\n */\nexport const getObservers = <T extends ComponentInstance>(element: WithObservers<T>) => {\n    const observers = (element[OBSERVERS_SYMBOL] || {}) as ObserversOf<T>;\n\n    if (!hasOwnProperty.call(element, OBSERVERS_SYMBOL)) {\n        return element[OBSERVERS_SYMBOL] = (Object.keys(observers) as (keyof PropertiesOf<T>)[])\n            .reduce((result, key) => {\n                result[key] = [...observers[key]];\n                return result;\n            }, {} as ObserversOf<T>);\n    }\n\n    return observers;\n};\n\n/**\n * Get observers for an element property.\n * @param element The node.\n * @param propertyName The name of the property.\n * @returns A list of observers.\n * @throws If the property is not defined.\n */\nexport const getPropertyObservers = <T extends ComponentInstance, P extends keyof PropertiesOf<T>>(element: T, propertyName: P) => {\n    if (!getProperty(element, propertyName)) {\n        throw new Error(`Missing property ${String(propertyName)}`);\n    }\n    const observers = getObservers(element);\n    return observers[propertyName] = observers[propertyName] || [];\n};\n\n/**\n * Add an observer for a property.\n * @param element The node context.\n * @param propertyName The name of the property to watch.\n * @param observer The observer function to add.\n */\nexport const addObserver = <T extends ComponentInstance, P extends keyof PropertiesOf<T>>(element: WithObservers<T>, propertyName: P, observer: PropertyObserver<T[P]>) => {\n    getPropertyObservers(element, propertyName).push(observer);\n};\n\n/**\n * Remove an observer for a property.\n * @param element The node context.\n * @param propertyName The name of the watched property.\n * @param observer The observer function to remove.\n */\nexport const removeObserver = <T extends ComponentInstance, P extends keyof PropertiesOf<T>>(element: WithObservers<T>, propertyName: P, observer: PropertyObserver<T[P]>) => {\n    const observers = getPropertyObservers(element, propertyName);\n    const io = observers.indexOf(observer);\n    if (io !== -1) {\n        observers.splice(io, 1);\n    }\n};\n\n/**\n * A decorator for property definition.\n * @param declaration The property declaration.\n * @returns The decorator initializer.\n */\nexport function property<TypeConstructorHint extends Constructor<unknown> = Constructor<unknown>>(declaration: PropertyDeclaration<TypeConstructorHint> = {}) {\n    return <T extends ComponentInstance, P extends keyof Members<T>>(\n        targetOrClassElement: T,\n        propertyKey?: P,\n        descriptor?: PropertyDeclaration<Constructor<T[P]>>\n    ) => createProperty(targetOrClassElement, declaration as PropertyDeclaration<Constructor<T[P]>>, propertyKey, descriptor);\n}\n\n/**\n * A decorator for state property definition.\n * @param declaration The state property declaration.\n * @returns The decorator initializer.\n */\nexport function state<TypeConstructorHint extends Constructor<unknown> = Constructor<unknown>>(declaration: PropertyDeclaration<TypeConstructorHint> = {}) {\n    return <T extends ComponentInstance, P extends keyof Members<T>>(\n        targetOrClassElement: T,\n        propertyKey?: P,\n        descriptor?: PropertyDeclaration<Constructor<T[P]>>\n    ) => createProperty(targetOrClassElement, { ...(declaration as PropertyDeclaration<Constructor<T[P]>>), state: true }, propertyKey, descriptor);\n}\n\n/**\n * A decorator for property observer.\n *\n * @param propertyKey The property key to observe.\n * @returns The decorator initializer.\n */\nexport function observe(propertyKey: string): Function {\n    return <T extends ComponentInstance, P extends MethodsOf<T>>(\n        targetOrClassElement: T,\n        methodKey?: P\n    ) => createObserver(targetOrClassElement, propertyKey as keyof PropertiesOf<T>, methodKey);\n}\n", "import type { Store, UpdateRequest, FunctionComponent } from './FunctionComponent';\nimport type { VProperties } from './JSX';\nimport type { ComponentInstance } from './Component';\n\n/**\n * A symbol for node render context.\n */\nconst CONTEXT_SYMBOL: unique symbol = Symbol();\n\n/**\n * A symbol for host component render context.\n */\nconst HOST_CONTEXT_SYMBOL: unique symbol = Symbol();\n\n/**\n * Represent a Node with render context symbols.\n */\nexport type WithContext<T extends Node> = T & {\n    [CONTEXT_SYMBOL]?: Context;\n    [HOST_CONTEXT_SYMBOL]?: Context;\n};\n\n/**\n * The node context interface.\n */\nexport type Context = {\n    children: Node[];\n    properties: WeakMap<Context, VProperties>;\n    host?: string;\n    keys?: Map<unknown, Node>;\n    fragment?: Context;\n    oldKeys?: Map<unknown, Node>;\n    oldKeyed?: Set<Node>;\n    store?: Store;\n    Function?: FunctionComponent<VProperties>;\n    start?: Node;\n    end?: Node;\n    parents?: Context[];\n    hosts?: ComponentInstance[];\n    currentIndex?: number;\n    namespace?: string;\n    requestUpdate?: UpdateRequest;\n};\n\n/**\n * Create a node context.\n * @param node The node scope of the context.\n * @returns A context object for the node.\n */\nexport const createContext = (node: Node) => {\n    const context: Context = {\n        children: [],\n        properties: new WeakMap(),\n        host: (node as unknown as ComponentInstance).is,\n    };\n\n    return context;\n};\n\n/**\n * Get the context attached to a node.\n * @param node The scope of the context.\n * @returns The context object (if it exists).\n */\nexport const getContext = <T extends Node>(node: WithContext<T>) => node[CONTEXT_SYMBOL];\n\n/**\n * Get (or create) the context attached to a node.\n * @param node The scope of the context.\n * @returns The context object (if it exists).\n */\nexport const getOrCreateContext = <T extends Node>(node: WithContext<T>) => (node[CONTEXT_SYMBOL] = node[CONTEXT_SYMBOL] || createContext(node));\n\n/**\n * Get the host context attached to a component.\n * @param node The scope of the context.\n * @returns The context object (if it exists).\n */\nexport const getHostContext = <T extends Node>(node: WithContext<T>) => node[HOST_CONTEXT_SYMBOL];\n\n/**\n * Get (or create) the host context attached to a component.\n * @param node The scope of the context.\n * @returns The context object (if it exists).\n */\nexport const getOrCreateHostContext = <T extends Node>(node: WithContext<T>) => (node[HOST_CONTEXT_SYMBOL] = node[HOST_CONTEXT_SYMBOL] || createContext(node));\n", "import type { ComponentConstructor, ComponentInstance } from './Component';\nimport type { Context } from './Context';\nimport { isConnected, appendChildImpl, removeChildImpl, insertBeforeImpl, replaceChildImpl, insertAdjacentElementImpl, getAttributeImpl, hasAttributeImpl, setAttributeImpl, removeAttributeImpl, createDocumentFragmentImpl, createElementImpl, createElementNSImpl, createTextNodeImpl, createCommentImpl, createEventImpl } from './helpers';\nimport { connect, disconnect, shouldEmulateLifeCycle, emulatingLifeCycle, isComponent, isComponentConstructor } from './Component';\nimport { customElements } from './CustomElementRegistry';\nimport { getContext, getOrCreateContext, getHostContext } from './Context';\n\n/**\n * Remove a slotted node from the old host positions.\n * @param newHost The new host parent of the slotted node.\n * @param node The slotted node.\n * @returns Updated hosts lists.\n */\nconst removeHosts = (newHost: Node, node: Node) => {\n    const childContext = getOrCreateContext(node);\n    const hosts = childContext.hosts;\n    if (!hosts) {\n        return childContext.hosts = [];\n    }\n\n    const parentContext = getHostContext(newHost);\n    if (!parentContext) {\n        return hosts;\n    }\n\n    const parents = parentContext.parents || [];\n    for (let i = 0, len = hosts.length; i < len; i++) {\n        const hostContext = getContext(hosts[i]);\n        if (!hostContext || parents.indexOf(hostContext) === -1) {\n            DOM.removeChild(hosts[i], node);\n            break;\n        }\n    }\n\n    return childContext.hosts = childContext.hosts || [];\n};\n\n/**\n * DOM is a singleton that components uses to access DOM methods.\n * By default, it uses browsers' DOM implementation, but it can be set to use a different one.\n * For example, in a Node context it is possibile to use DNA thanks to the `jsdom` dom implementation.\n * It also handle element life cycle for custom elements unless otherwise specified.\n */\nexport const DOM = {\n    /**\n     * Create a document fragment.\n     *\n     * @returns The new DOM fragment.\n     */\n    createDocumentFragment: createDocumentFragmentImpl,\n\n    /**\n     * Create a new DOM element node for the specified tag.\n     * @param qualifiedName The specified tag.\n     * @param options Create element options.\n     * @returns The new DOM element instance.\n     */\n    createElement<K extends keyof HTMLElementTagNameMap>(qualifiedName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K] {\n        const is = options && options.is;\n        const name = is || qualifiedName.toLowerCase();\n        const node = createElementImpl(qualifiedName);\n        const constructor = customElements.get(name);\n        if (constructor && isComponentConstructor(constructor) && !(node instanceof constructor)) {\n            constructor.upgrade(node);\n        }\n        return node;\n    },\n\n    /**\n     * Create a new DOM element node for the specified tag using a namespace.\n     * @param namespaceURI The namespace of the tag.\n     * @param qualifiedName The specified tag.\n     * @returns The new DOM element instance.\n     */\n    createElementNS(namespaceURI: Parameters<typeof createElementNSImpl>[0], qualifiedName: Parameters<typeof createElementNSImpl>[1]) {\n        if (namespaceURI === 'http://www.w3.org/1999/xhtml') {\n            return this.createElement(qualifiedName as keyof HTMLElementTagNameMap);\n        }\n        return createElementNSImpl(namespaceURI, qualifiedName as keyof SVGElementTagNameMap);\n    },\n\n    /**\n     * Create a new DOM text node from the specified value.\n     *\n     * @param data The specified value.\n     * @returns The new DOM text instance.\n     */\n    createTextNode: createTextNodeImpl,\n\n    /**\n     * Create a new DOM comment node from the specified value.\n     *\n     * @param data The specified value.\n     * @returns The new DOM text instance.\n     */\n    createComment(data: string): Comment {\n        return createCommentImpl(data || '');\n    },\n\n    /**\n     * Instantiate an Event.\n     * @param typeArg The name of the event.\n     * @param eventInitDict A set of options for the event, such as detail and bubbling.\n     * @returns The new Event instance.\n     */\n    createEvent(typeArg: string, eventInitDict: CustomEventInit<unknown> = {}) {\n        return createEventImpl(typeArg, eventInitDict);\n    },\n\n    /**\n     * Append a child to an element.\n     *\n     * @param parent The parent element.\n     * @param newChild The child to add.\n     * @param slot Should add a slot node.\n     * @param update Should invoke component update.\n     * @returns The appended child.\n     */\n    appendChild<T extends Node>(parent: Node, newChild: T, slot = isComponent(parent), update = true): T {\n        const oldParent = newChild.parentNode;\n        const context = slot ? getHostContext(parent) as Context : getOrCreateContext(parent);\n        if (slot) {\n            const slotted = context.children;\n            const previousIndex = slotted.indexOf(newChild);\n            if (previousIndex !== -1) {\n                slotted.splice(previousIndex, 1);\n            } else {\n                const hosts = removeHosts(parent, newChild);\n                hosts.push(parent as ComponentInstance);\n            }\n            slotted.push(newChild);\n            if (update) {\n                (parent as ComponentInstance).forceUpdate();\n            }\n            return newChild;\n        }\n        if (oldParent) {\n            DOM.removeChild(oldParent, newChild, false);\n        }\n        context.children.push(newChild);\n        appendChildImpl.call(parent, newChild);\n        if (emulatingLifeCycle() && isConnected.call(newChild)) {\n            connect(newChild);\n        }\n        return newChild;\n    },\n\n    /**\n     * Remove a child from an element.\n     *\n     * @param parent The parent element.\n     * @param oldChild The child to remove.\n     * @param slot Should remove a slot node.\n     * @param update Should invoke component update.\n     * @returns The removed child.\n     */\n    removeChild<T extends Node>(parent: Node, oldChild: T, slot = isComponent(parent), update = true): T {\n        const context = slot ? getHostContext(parent) as Context : getOrCreateContext(parent);\n        if (slot) {\n            const oldChildContext = getOrCreateContext(oldChild);\n            const slotted = context.children;\n            const io = slotted.indexOf(oldChild);\n            if (io !== -1) {\n                const hosts = oldChildContext.hosts;\n                if (hosts) {\n                    oldChildContext.hosts = hosts.slice(0, hosts.indexOf(parent as ComponentInstance));\n                }\n                slotted.splice(io, 1);\n                if (update) {\n                    (parent as ComponentInstance).forceUpdate();\n                }\n            }\n            return oldChild;\n        }\n        const connected = isConnected.call(oldChild);\n        const childNodes = context.children;\n        const io = childNodes.indexOf(oldChild);\n        if (io !== -1) {\n            childNodes.splice(io, 1);\n        }\n        removeChildImpl.call(parent, oldChild);\n        if (emulatingLifeCycle() && connected) {\n            disconnect(oldChild);\n        }\n        return oldChild;\n    },\n\n    /**\n     * Insert a child before another in an element.\n     *\n     * @param parent The parent element.\n     * @param newChild The child to insert.\n     * @param refChild The referred node.\n     * @param slot Should insert a slot node.\n     * @param update Should invoke component update.\n     * @returns The inserted child.\n     */\n    insertBefore<T extends Node>(parent: Node, newChild: T, refChild: Node | null, slot = isComponent(parent), update = true): T {\n        const context = slot ? getHostContext(parent) as Context : getOrCreateContext(parent);\n        if (slot) {\n            const slotted = context.children;\n            const previousIndex = slotted.indexOf(newChild);\n            if (previousIndex !== -1) {\n                slotted.splice(previousIndex, 1);\n            } else {\n                const hosts = removeHosts(parent, newChild);\n                hosts.push(parent as ComponentInstance);\n            }\n\n            if (refChild) {\n                const refIndex = slotted.indexOf(refChild);\n                if (refIndex !== -1) {\n                    slotted.splice(refIndex, 0, newChild);\n                }\n            } else {\n                slotted.push(newChild);\n            }\n            if (update) {\n                (parent as ComponentInstance).forceUpdate();\n            }\n            return newChild;\n        }\n\n        const parentNode = newChild.parentNode;\n        if (parentNode) {\n            DOM.removeChild(parentNode, newChild, false);\n        }\n        const childNodes = context.children;\n        const oldIo = childNodes.indexOf(newChild);\n        if (oldIo !== -1) {\n            childNodes.splice(oldIo, 1);\n        }\n        const io = refChild ? childNodes.indexOf(refChild) : -1;\n        if (io !== -1) {\n            childNodes.splice(io, 0, newChild);\n        } else {\n            childNodes.push(newChild);\n        }\n        insertBeforeImpl.call(parent, newChild, refChild);\n        if (emulatingLifeCycle() && isConnected.call(newChild)) {\n            connect(newChild);\n        }\n        return newChild;\n    },\n\n    /**\n     * Replace a child with another in an element.\n     *\n     * @param parent The parent element.\n     * @param newChild The child to insert.\n     * @param oldChild The node to replace.\n     * @param slot Should replace a slot node.\n     * @param update Should invoke component update.\n     * @returns The replaced child.\n     */\n    replaceChild<T extends Node>(parent: Node, newChild: Node, oldChild: T, slot = isComponent(parent), update = true): T {\n        const context = slot ? getHostContext(parent) as Context : getOrCreateContext(parent);\n        const parentNode = newChild.parentNode;\n\n        if (slot) {\n            const slotted = context.children;\n            const previousIndex = slotted.indexOf(newChild);\n            if (previousIndex !== -1) {\n                slotted.splice(previousIndex, 1);\n            } else {\n                const hosts = removeHosts(parent, newChild);\n                hosts.push(parent as ComponentInstance);\n            }\n\n            const io = slotted.indexOf(oldChild);\n            slotted.splice(io, 1, newChild);\n            removeHosts(parent, oldChild);\n            if (update) {\n                (parent as ComponentInstance).forceUpdate();\n            }\n            return oldChild;\n        }\n        if (parentNode && newChild !== oldChild) {\n            DOM.removeChild(parentNode, newChild, false);\n        }\n        if (emulatingLifeCycle() && isConnected.call(oldChild)) {\n            disconnect(oldChild);\n        }\n        const childNodes = context.children;\n        const io = childNodes.indexOf(oldChild);\n        if (io !== -1) {\n            childNodes.splice(io, 1);\n        }\n        replaceChildImpl.call(parent, newChild, oldChild);\n        if (emulatingLifeCycle() && isConnected.call(newChild)) {\n            connect(newChild);\n        }\n        return oldChild;\n    },\n\n    /**\n     * Insert a child at the given position.\n     *\n     * @param parent The parent element.\n     * @param position The position of the insertion.\n     * @param insertedElement The child to insert.\n     * @param slot Should insert a slot node.\n     * @param update Should invoke component update.\n     * @returns The inserted child.\n     */\n    insertAdjacentElement(parent: Element, position: InsertPosition, insertedElement: Element, slot = isComponent(parent), update = true): Element | null {\n        if (position === 'afterbegin') {\n            const refChild = isComponent(parent) ? (parent.slotChildNodes as Node[])[0] : parent.firstChild;\n            return DOM.insertBefore(parent, insertedElement, refChild, slot, update);\n        }\n        if (position === 'beforeend') {\n            return DOM.insertBefore(parent, insertedElement, null, slot, update);\n        }\n\n        return insertAdjacentElementImpl.call(parent, position, insertedElement);\n    },\n\n    /**\n     * Get a Component attribute.\n     * @param element The node element.\n     * @param qualifiedName The attribute name.\n     * @returns The attribute value.\n     */\n    getAttribute(element: Element, qualifiedName: string): string | null {\n        return getAttributeImpl.call(element, qualifiedName);\n    },\n\n    /**\n     * Check if an element has an attribute.\n     * @param element The node element to check.\n     * @param qualifiedName The attribute name to check.\n     * @returns True if the element has the attribute.\n     */\n    hasAttribute(element: Element, qualifiedName: string): boolean {\n        return hasAttributeImpl.call(element, qualifiedName);\n    },\n\n    /**\n     * Add/set an attribute to an element.\n     * @param element The element node to update.\n     * @param qualifiedName The attribute name to add/set.\n     * @param value The value to set.\n     */\n    setAttribute(element: Element, qualifiedName: string, value: string): void {\n        if (shouldEmulateLifeCycle(element)) {\n            const constructor = element.constructor as ComponentConstructor<typeof element>;\n            const observedAttributes = constructor.observedAttributes;\n            const observed = observedAttributes && observedAttributes.indexOf(qualifiedName) !== -1;\n            if (!observed) {\n                setAttributeImpl.call(element, qualifiedName, value);\n                return;\n            }\n\n            const oldValue = DOM.getAttribute(element, qualifiedName);\n            setAttributeImpl.call(element, qualifiedName, value);\n            (element as ComponentInstance).attributeChangedCallback(qualifiedName, oldValue, value);\n            return;\n        }\n        setAttributeImpl.call(element, qualifiedName, value);\n    },\n\n    /**\n     * Remove an element's attribute.\n     * @param element The element node to update.\n     * @param qualifiedName The attribute name to remove.\n     */\n    removeAttribute(element: Element, qualifiedName: string): void {\n        if (shouldEmulateLifeCycle(element)) {\n            const constructor = element.constructor as ComponentConstructor<typeof element>;\n            const observedAttributes = constructor.observedAttributes;\n            const observed = observedAttributes && observedAttributes.indexOf(qualifiedName) !== -1;\n            if (!observed) {\n                removeAttributeImpl.call(element, qualifiedName);\n                return;\n            }\n\n            const oldValue = DOM.getAttribute(element, qualifiedName);\n            removeAttributeImpl.call(element, qualifiedName);\n            (element as ComponentInstance).attributeChangedCallback(qualifiedName, oldValue, null);\n        }\n        removeAttributeImpl.call(element, qualifiedName);\n    },\n};\n", "import type { Constructor, ClassElement } from './helpers';\nimport type { ComponentInstance, ComponentConstructor, MethodsOf } from './Component';\nimport { HTMLElementConstructor, isElement, isEvent, matchesImpl, createEventImpl, hasOwnProperty, getOwnPropertyDescriptor, getPrototypeOf } from './helpers';\n\n/**\n * A Symbol which contains all Node delegation.\n */\nconst EVENT_CALLBACKS_SYMBOL: unique symbol = Symbol();\n\n/**\n * Async event interface.\n */\nexport type AsyncEvent = Event & {\n    respondWith(callback: () => Promise<unknown>): void;\n};\n\n/**\n * Describe the signature of a delegated event callback.\n * @param event The original DOM event.\n * @param target The matched delegated element.\n */\nexport type DelegatedEventCallback = (event: Event, target?: Node) => unknown;\n\n/**\n * A descriptor for an event delegation.\n */\nexport type DelegatedEventDescriptor = AddEventListenerOptions & {\n    target?: EventTarget;\n    callback: DelegatedEventCallback;\n};\n\n/**\n * Property configuration for properties accessor.\n */\nexport type ListenerConfig = DelegatedEventCallback | DelegatedEventDescriptor;\n\n/**\n * A collector for event delegations.\n */\ntype DelegationList = {\n    /**\n     * A list of delegation descriptors.\n     */\n    descriptors: {\n        /**\n         * The name of the delegated event.\n         */\n        event: string;\n        /**\n         * The selector for the delegated event.\n         */\n        selector: string | null;\n        /**\n         * The event target.\n         */\n        target: EventTarget | null;\n        /**\n         * The callback for the delegated event.\n         */\n        callback?: DelegatedEventCallback;\n    }[];\n\n    /**\n     * The real event listener.\n     */\n    listener: EventListenerOrEventListenerObject;\n}\n\n/**\n * An object with event delegations.\n */\ntype WithEventDelegations = {\n    [EVENT_CALLBACKS_SYMBOL]?: {\n        [key: string]: DelegationList;\n    };\n}\n\nconst assertNode = (element: unknown) => {\n    if (!isElement(element)) {\n        throw new TypeError('The provided element must be a Node');\n    }\n};\n\nconst assertEvent = (event: unknown) => {\n    if (!isEvent(event)) {\n        throw new TypeError('The provided object must be an Event');\n    }\n};\n\nconst assertEventName = (eventName: unknown) => {\n    if (typeof eventName !== 'string') {\n        throw new TypeError('The provided event name must be a string');\n    }\n};\n\nconst assertEventSelector = (selector: unknown) => {\n    if (selector !== null && typeof selector !== 'string') {\n        throw new TypeError('The provided selector must be a string or null');\n    }\n};\n\nconst assertEventCallback = (callback: unknown) => {\n    if (typeof callback !== 'function') {\n        throw new TypeError('The provided callback must be a function');\n    }\n};\n\nconst assertEventBubbles = (bubbles: unknown) => {\n    if (typeof bubbles !== 'boolean') {\n        throw new TypeError('The provided bubbles option must be a boolean');\n    }\n};\n\nconst assertEventCancelable = (cancelable: unknown) => {\n    if (typeof cancelable !== 'boolean') {\n        throw new TypeError('The provided cancelable option must be a boolean');\n    }\n};\n\nconst assertEventComposed = (composed: unknown) => {\n    if (typeof composed !== 'undefined' && typeof composed !== 'boolean') {\n        throw new TypeError('The provided composed option must be a boolean');\n    }\n};\n\n/**\n * Delegate an Event listener.\n *\n * @param element The root element for the delegation\n * @param eventName The event name to listen\n * @param selector The selector to delegate\n * @param callback The callback to trigger when an Event matches the delegation\n * @param options An options object that specifies characteristics about the event listener. @see [MDN]{@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener}\n */\nexport const delegateEventListener = (element: Element, eventName: string, selector: string|null, callback: DelegatedEventCallback, options?: AddEventListenerOptions) => {\n    const delegatedElement: Node & WithEventDelegations = element;\n\n    assertNode(element);\n    assertEventName(eventName);\n    assertEventSelector(selector);\n    assertEventCallback(callback);\n\n    // get all delegations\n    const delegations = delegatedElement[EVENT_CALLBACKS_SYMBOL] = delegatedElement[EVENT_CALLBACKS_SYMBOL] || {};\n    // initialize the delegation list\n    const callbacks: DelegationList = delegations[eventName] = delegations[eventName] || {\n        descriptors: [],\n    };\n    const descriptors = callbacks.descriptors;\n    // check if the event has already been delegated\n    if (!callbacks.listener) {\n        // setup the listener\n        callbacks.listener = (event) => {\n            if (!event.target) {\n                return;\n            }\n            const eventTarget = event.target as Node;\n            // wrap the Event's stopPropagation in order to prevent other delegations from the same root\n            const originalStopPropagation = event.stopPropagation;\n            const originalImmediatePropagation = event.stopImmediatePropagation;\n            let stopped = false;\n            let stoppedImmediated = false;\n            event.stopPropagation = () => {\n                stopped = true;\n                // exec the real stopPropagation method\n                return originalStopPropagation.call(event);\n            };\n            event.stopImmediatePropagation = () => {\n                stopped = true;\n                stoppedImmediated = true;\n                // exec the real stopPropagation method\n                return originalImmediatePropagation.call(event);\n            };\n\n            // filter matched selector for the event\n            const filtered: { target: Node; callback: DelegatedEventCallback }[] = [];\n            for (let i = 0; i < descriptors.length; i++) {\n                const { selector, callback } = descriptors[i];\n                let selectorTarget;\n                if (selector) {\n                    let target = eventTarget;\n                    while (target && target !== element) {\n                        if (isElement(target) && matchesImpl.call(target, selector)) {\n                            selectorTarget = target;\n                            break;\n                        }\n                        target = target.parentNode as Node;\n                    }\n                } else {\n                    selectorTarget = element;\n                }\n                if (selectorTarget) {\n                    filtered.push({\n                        target: selectorTarget,\n                        callback: callback as DelegatedEventCallback,\n                    });\n                }\n            }\n\n            let lastTarget: Node;\n            filtered\n                // clone the array in order to correctly sort callbacks in old browsers\n                .slice(0)\n                // reorder targets by position in the dom tree.\n                .sort((match1, match2) => {\n                    if (match1.target === match2.target) {\n                        return filtered.indexOf(match1) - filtered.indexOf(match2);\n                    }\n                    return match1.target.contains(match2.target) ? filtered.length : -filtered.length;\n                })\n                // trigger the callback\n                .some(({ callback, target }) => {\n                    if (stoppedImmediated) {\n                        return true;\n                    }\n                    if (stopped && target !== lastTarget) {\n                        return true;\n                    }\n                    lastTarget = target;\n                    return callback.call(element, event, target) === false;\n                });\n        };\n\n        element.addEventListener(eventName, callbacks.listener, options);\n    }\n\n    // add the delegation to the list\n    descriptors.push({ event: eventName, callback, selector, target: null });\n};\n\n/**\n * Remove an Event delegation.\n *\n * @param element The root element of the delegation\n * @param eventName The Event name to undelegate\n * @param selector The selector to undelegate\n * @param callback The callback to remove\n */\nexport const undelegateEventListener = (element: Element, eventName: string, selector: string | null, callback: DelegatedEventCallback) => {\n    assertNode(element);\n    assertEventName(eventName);\n    assertEventSelector(selector);\n    assertEventCallback(callback);\n\n    const delegatedElement: Node & WithEventDelegations = element;\n    // get all delegations\n    const delegations = delegatedElement[EVENT_CALLBACKS_SYMBOL];\n    if (!delegations) {\n        return;\n    }\n    if (!(eventName in delegations)) {\n        return;\n    }\n    const { descriptors, listener } = delegations[eventName];\n    // get the list of delegations\n    // find the index of the callback to remove in the list\n    for (let i = 0; i < descriptors.length; i++) {\n        const descriptor = descriptors[i];\n        if (descriptor.selector === selector && descriptor.callback === callback) {\n            descriptors.splice(i, 1);\n            if (descriptors.length === 0) {\n                element.removeEventListener(eventName, listener);\n            }\n        }\n    }\n};\n\n/**\n * Create custom Event.\n *\n * @param event The event to dispatch or the name of the synthetic event to create.\n * @param detail Detail object of the event.\n * @param bubbles Should the event bubble.\n * @param cancelable Should the event be cancelable.\n * @param composed Is the event composed.\n * @returns The custom event.\n */\nfunction initEvent(event: Event | string, detail?: CustomEventInit, bubbles?: boolean, cancelable?: boolean, composed?: boolean) {\n    if (typeof event !== 'string') {\n        assertEvent(event);\n        return event;\n    }\n\n    assertEventBubbles(bubbles);\n    assertEventCancelable(cancelable);\n    assertEventComposed(composed);\n\n    return createEventImpl(event, {\n        detail,\n        bubbles,\n        cancelable,\n        composed,\n    });\n}\n\n/**\n * Dispatch a custom Event.\n * @param element The dispatcher node.\n * @param event The event to dispatch or the name of the synthetic event to create.\n * @param detail Detail object of the event.\n * @param bubbles Should the event bubble.\n * @param cancelable Should the event be cancelable.\n * @param composed Is the event composed.\n * @returns True if either event's cancelable attribute value is false or its preventDefault() method was not invoked, and false otherwise.\n */\nexport const dispatchEvent = (element: Element, event: Event | string, detail?: CustomEventInit['detail'], bubbles: boolean = true, cancelable: boolean = true, composed: boolean = false): boolean => {\n    assertNode(element);\n    event = initEvent(event, detail, bubbles, cancelable, composed);\n    return HTMLElementConstructor.prototype.dispatchEvent.call(element, event);\n};\n\n/**\n * Dispatch an async custom Event.\n *\n * @param element The dispatcher node.\n * @param event The event to dispatch or the name of the synthetic event to create.\n * @param detail Detail object of the event.\n * @param bubbles Should the event bubble.\n * @param cancelable Should the event be cancelable.\n * @param composed Is the event composed.\n */\nexport const dispatchAsyncEvent = async (element: Element, event: Event | string, detail?: CustomEventInit['detail'], bubbles: boolean = true, cancelable: boolean = true, composed: boolean = false): Promise<unknown[]> => {\n    const asyncEvent = initEvent(event, detail, bubbles, cancelable, composed) as unknown as AsyncEvent;\n    const promises: unknown[] = [];\n    asyncEvent.respondWith = function(callback) {\n        promises.push(callback());\n    };\n    if (!dispatchEvent(element, asyncEvent)) {\n        if (promises.length === 0) {\n            throw new Error('Event has been canceled');\n        }\n    }\n    return await Promise.all(promises);\n};\n\n/**\n * A Symbol which contains all listeners instances of a component constructor.\n */\nconst LISTENERS_SYMBOL: unique symbol = Symbol();\n\n/**\n * An object with listeners.\n */\ntype WithListeners<T extends ComponentInstance> = T & {\n    [LISTENERS_SYMBOL]?: Listener[];\n};\n\n/**\n * The listener interface.\n */\ntype Listener = {\n    event: string;\n    selector: string | null;\n    target: EventTarget | null;\n    callback: DelegatedEventCallback;\n    options?: AddEventListenerOptions;\n};\n\n/**\n * Retrieve all listeners descriptors.\n * @param prototype The component prototype.\n * @returns A list of listeners.\n */\nexport const getListeners = <T extends ComponentInstance>(prototype: WithListeners<T>) => {\n    const listeners = prototype[LISTENERS_SYMBOL];\n    if (!listeners) {\n        return [];\n    }\n\n    if (!hasOwnProperty.call(prototype, LISTENERS_SYMBOL)) {\n        return listeners.slice(0);\n    }\n\n    return listeners;\n};\n\n/**\n * Set listeners to a prototype.\n * @param prototype The component prototype.\n * @param listeners The list of listeners to set.\n */\nexport const setListeners = <T extends ComponentInstance>(prototype: WithListeners<T>, listeners: Listener[]) => {\n    prototype[LISTENERS_SYMBOL] = listeners;\n};\n\n/**\n * Add an event listener to the prototype.\n * @param prototype The component prototype.\n * @param eventName The name of the event to listen.\n * @param target The event target of the listener.\n * @param selector The selector event target of the listener.\n * @param callback The event callback.\n * @param options The event listener options.\n */\nexport function defineListener<T extends ComponentInstance>(\n    prototype: WithListeners<T>,\n    eventName: string,\n    target: EventTarget | null,\n    selector: string | null,\n    callback: DelegatedEventCallback,\n    options: AddEventListenerOptions = {}\n) {\n    const listeners = getListeners(prototype);\n    setListeners(prototype, listeners);\n    listeners.push({\n        event: eventName,\n        selector,\n        callback,\n        target,\n        options,\n    });\n}\n\n/**\n * Define component listeners.\n * @param prototype The component prototype.\n */\nexport const defineListeners = <T extends ComponentInstance>(prototype: T) => {\n    const constructor = prototype.constructor as ComponentConstructor<T>;\n    let ctr = constructor;\n    while (ctr && ctr.prototype && ctr !== HTMLElementConstructor) {\n        if (hasOwnProperty.call(ctr.prototype, LISTENERS_SYMBOL)) {\n            break;\n        }\n        const listenersDescriptor = getOwnPropertyDescriptor(ctr, 'listeners');\n        const listenersGetter = listenersDescriptor && listenersDescriptor.get;\n        if (listenersGetter) {\n            const listenerDescriptors = (listenersGetter.call(constructor) || {}) as {\n                [key: string]: ListenerConfig;\n            };\n            // register listeners\n            for (const eventPath in listenerDescriptors) {\n                const paths = eventPath.trim().split(' ');\n                const eventName = paths.shift() as string;\n                const selector = paths.length ? paths.join(' ') : null;\n                const descriptor = listenerDescriptors[eventPath];\n                const { callback, target = null, ...options } = typeof descriptor === 'object' ? descriptor : { callback: descriptor };\n                defineListener(prototype, eventName, target, selector, callback, options);\n            }\n        }\n        ctr = getPrototypeOf(ctr);\n    }\n};\n\n/**\n * Add a property observer to a component prototype.\n * @param targetOrClassElement The component prototype.\n * @param eventName The name of the event.\n * @param target The event target for the listener.\n * @param selector The selector event target for the listener.\n * @param options Listener options.\n * @param methodKey The method name.\n * @returns The property descriptor.\n */\nexport const createListener = <T extends ComponentInstance, P extends MethodsOf<T>>(\n    targetOrClassElement: T,\n    eventName: string,\n    target: EventTarget | null,\n    selector: string | null,\n    options: AddEventListenerOptions,\n    methodKey?: P\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n): any => {\n    if (methodKey !== undefined) {\n        const method = targetOrClassElement[methodKey] as unknown as DelegatedEventCallback;\n        defineListener(targetOrClassElement, eventName, target, selector, method, options);\n        return;\n    }\n\n    const element = targetOrClassElement as unknown as ClassElement;\n    return {\n        ...element,\n        finisher(constructor: Constructor<T>) {\n            const prototype = constructor.prototype as T;\n            const method = prototype[element.key as P] as unknown as DelegatedEventCallback;\n            defineListener(prototype, eventName, target, selector, method, options);\n        },\n    };\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isEventTarget = (target: any): target is EventTarget => typeof target === 'object' && 'addEventListener' in target;\n\nfunction listen(eventName: string, options?: AddEventListenerOptions): Function;\nfunction listen(eventName: string, selector: string, options?: AddEventListenerOptions): Function;\nfunction listen(eventName: string, target: EventTarget, options?: AddEventListenerOptions): Function;\n/**\n * A decorator for listening DOM events.\n * @param eventName The name of the event to listen.\n * @param target The event target for the listener.\n * @param options Options to pass to addEventListener.\n * @returns The decorator initializer.\n */\nfunction listen(eventName: string, target?: string | EventTarget | AddEventListenerOptions, options?: AddEventListenerOptions) {\n    return <T extends ComponentInstance, P extends MethodsOf<T>>(\n        targetOrClassElement: T,\n        methodKey: P\n    ) => createListener(\n        targetOrClassElement,\n        eventName,\n        isEventTarget(target) ? target : null,\n        typeof target === 'string' ? target : null,\n        (!isEventTarget(target) && typeof target !== 'string' ? target : options) || {},\n        methodKey\n    );\n}\n\nexport { listen };\n", "var n=function(t,s,r,e){var u;s[0]=0;for(var h=1;h<s.length;h++){var p=s[h++],a=s[h]?(s[0]|=p?1:2,r[s[h++]]):s[++h];3===p?e[0]=a:4===p?e[1]=Object.assign(e[1]||{},a):5===p?(e[1]=e[1]||{})[s[++h]]=a:6===p?e[1][s[++h]]+=a+\"\":p?(u=t.apply(a,n(t,a,r,[\"\",null])),e.push(u),a[0]?s[0]|=2:(s[h-2]=0,s[h]=u)):e.push(a)}return e},t=new Map;export default function(s){var r=t.get(this);return r||(r=new Map,t.set(this,r)),(r=n(this,r.get(s)||(r.set(s,r=function(n){for(var t,s,r=1,e=\"\",u=\"\",h=[0],p=function(n){1===r&&(n||(e=e.replace(/^\\s*\\n\\s*|\\s*\\n\\s*$/g,\"\")))?h.push(0,n,e):3===r&&(n||e)?(h.push(3,n,e),r=2):2===r&&\"...\"===e&&n?h.push(4,n,0):2===r&&e&&!n?h.push(5,0,!0,e):r>=5&&((e||!n&&5===r)&&(h.push(r,0,e,s),r=6),n&&(h.push(r,n,0,s),r=6)),e=\"\"},a=0;a<n.length;a++){a&&(1===r&&p(),p(a));for(var l=0;l<n[a].length;l++)t=n[a][l],1===r?\"<\"===t?(p(),h=[h],r=3):e+=t:4===r?\"--\"===e&&\">\"===t?(r=1,e=\"\"):e=t+e[0]:u?t===u?u=\"\":e+=t:'\"'===t||\"'\"===t?u=t:\">\"===t?(p(),r=1):r&&(\"=\"===t?(r=5,s=e,e=\"\"):\"/\"===t&&(r<5||\">\"===n[a][l+1])?(p(),3===r&&(h=h[0]),r=h,(h=h[0]).push(2,0,r),r=0):\" \"===t||\"\\t\"===t||\"\\n\"===t||\"\\r\"===t?(p(),r=2):e+=t),3===r&&\"!--\"===e&&(r=4,h=h[0])}return p(),h}(s)),r),arguments,[])).length>1?r:r[0]}\n", "/* eslint-disable @typescript-eslint/no-namespace, @typescript-eslint/no-empty-interface */\nimport type { Observable } from './Observable';\nimport type { CustomElementConstructor } from './CustomElementRegistry';\nimport type { Props } from './Component';\nimport type { FunctionComponent } from './FunctionComponent';\nimport { isArray, isNode } from './helpers';\nimport { customElements, isCustomElementConstructor } from './CustomElementRegistry';\n\n// All the WAI-ARIA 1.1 attributes from https://www.w3.org/TR/wai-aria-1.1/\nexport interface AriaAttributes {\n    /** Identifies the currently active element when DOM focus is on a composite widget, textbox, group, or application. */\n    'aria-activedescendant'?: string | undefined;\n    /** Indicates whether assistive technologies will present all, or only parts of, the changed region based on the change notifications defined by the aria-relevant attribute. */\n    'aria-atomic'?: boolean | 'false' | 'true' | undefined;\n    /**\n     * Indicates whether inputting text could trigger display of one or more predictions of the user's intended value for an input and specifies how predictions would be\n     * presented if they are made.\n     */\n    'aria-autocomplete'?: 'none' | 'inline' | 'list' | 'both' | undefined;\n    /** Indicates an element is being modified and that assistive technologies MAY want to wait until the modifications are complete before exposing them to the user. */\n    'aria-busy'?: boolean | 'false' | 'true' | undefined;\n    /**\n     * Indicates the current \"checked\" state of checkboxes, radio buttons, and other widgets.\n     * @see aria-pressed @see aria-selected.\n     */\n    'aria-checked'?: boolean | 'false' | 'mixed' | 'true' | undefined;\n    /**\n     * Defines the total number of columns in a table, grid, or treegrid.\n     * @see aria-colindex.\n     */\n    'aria-colcount'?: number | undefined;\n    /**\n     * Defines an element's column index or position with respect to the total number of columns within a table, grid, or treegrid.\n     * @see aria-colcount @see aria-colspan.\n     */\n    'aria-colindex'?: number | undefined;\n    /**\n     * Defines the number of columns spanned by a cell or gridcell within a table, grid, or treegrid.\n     * @see aria-colindex @see aria-rowspan.\n     */\n    'aria-colspan'?: number | undefined;\n    /**\n     * Identifies the element (or elements) whose contents or presence are controlled by the current element.\n     * @see aria-owns.\n     */\n    'aria-controls'?: string | undefined;\n    /** Indicates the element that represents the current item within a container or set of related elements. */\n    'aria-current'?: boolean | 'false' | 'true' | 'page' | 'step' | 'location' | 'date' | 'time' | undefined;\n    /**\n     * Identifies the element (or elements) that describes the object.\n     * @see aria-labelledby\n     */\n    'aria-describedby'?: string | undefined;\n    /**\n     * Identifies the element that provides a detailed, extended description for the object.\n     * @see aria-describedby.\n     */\n    'aria-details'?: string | undefined;\n    /**\n     * Indicates that the element is perceivable but disabled, so it is not editable or otherwise operable.\n     * @see aria-hidden @see aria-readonly.\n     */\n    'aria-disabled'?: boolean | 'false' | 'true' | undefined;\n    /**\n     * Indicates what functions can be performed when a dragged object is released on the drop target.\n     * @deprecated in ARIA 1.1\n     */\n    'aria-dropeffect'?: 'none' | 'copy' | 'execute' | 'link' | 'move' | 'popup' | undefined;\n    /**\n     * Identifies the element that provides an error message for the object.\n     * @see aria-invalid @see aria-describedby.\n     */\n    'aria-errormessage'?: string | undefined;\n    /** Indicates whether the element, or another grouping element it controls, is currently expanded or collapsed. */\n    'aria-expanded'?: boolean | 'false' | 'true' | undefined;\n    /**\n     * Identifies the next element (or elements) in an alternate reading order of content which, at the user's discretion,\n     * allows assistive technology to override the general default of reading in document source order.\n     */\n    'aria-flowto'?: string | undefined;\n    /**\n     * Indicates an element's \"grabbed\" state in a drag-and-drop operation.\n     * @deprecated in ARIA 1.1\n     */\n    'aria-grabbed'?: boolean | 'false' | 'true' | undefined;\n    /** Indicates the availability and type of interactive popup element, such as menu or dialog, that can be triggered by an element. */\n    'aria-haspopup'?: boolean | 'false' | 'true' | 'menu' | 'listbox' | 'tree' | 'grid' | 'dialog' | undefined;\n    /**\n     * Indicates whether the element is exposed to an accessibility API.\n     * @see aria-disabled.\n     */\n    'aria-hidden'?: boolean | 'false' | 'true' | undefined;\n    /**\n     * Indicates the entered value does not conform to the format expected by the application.\n     * @see aria-errormessage.\n     */\n    'aria-invalid'?: boolean | 'false' | 'true' | 'grammar' | 'spelling' | undefined;\n    /** Indicates keyboard shortcuts that an author has implemented to activate or give focus to an element. */\n    'aria-keyshortcuts'?: string | undefined;\n    /**\n     * Defines a string value that labels the current element.\n     * @see aria-labelledby.\n     */\n    'aria-label'?: string | undefined;\n    /**\n     * Identifies the element (or elements) that labels the current element.\n     * @see aria-describedby.\n     */\n    'aria-labelledby'?: string | undefined;\n    /** Defines the hierarchical level of an element within a structure. */\n    'aria-level'?: number | undefined;\n    /** Indicates that an element will be updated, and describes the types of updates the user agents, assistive technologies, and user can expect from the live region. */\n    'aria-live'?: 'off' | 'assertive' | 'polite' | undefined;\n    /** Indicates whether an element is modal when displayed. */\n    'aria-modal'?: boolean | 'false' | 'true' | undefined;\n    /** Indicates whether a text box accepts multiple lines of input or only a single line. */\n    'aria-multiline'?: boolean | 'false' | 'true' | undefined;\n    /** Indicates that the user may select more than one item from the current selectable descendants. */\n    'aria-multiselectable'?: boolean | 'false' | 'true' | undefined;\n    /** Indicates whether the element's orientation is horizontal, vertical, or unknown/ambiguous. */\n    'aria-orientation'?: 'horizontal' | 'vertical' | undefined;\n    /**\n     * Identifies an element (or elements) in order to define a visual, functional, or contextual parent/child relationship\n     * between DOM elements where the DOM hierarchy cannot be used to represent the relationship.\n     * @see aria-controls.\n     */\n    'aria-owns'?: string | undefined;\n    /**\n     * Defines a short hint (a word or short phrase) intended to aid the user with data entry when the control has no value.\n     * A hint could be a sample value or a brief description of the expected format.\n     */\n    'aria-placeholder'?: string | undefined;\n    /**\n     * Defines an element's number or position in the current set of listitems or treeitems. Not required if all elements in the set are present in the DOM.\n     * @see aria-setsize.\n     */\n    'aria-posinset'?: number | undefined;\n    /**\n     * Indicates the current \"pressed\" state of toggle buttons.\n     * @see aria-checked @see aria-selected.\n     */\n    'aria-pressed'?: boolean | 'false' | 'mixed' | 'true' | undefined;\n    /**\n     * Indicates that the element is not editable, but is otherwise operable.\n     * @see aria-disabled.\n     */\n    'aria-readonly'?: boolean | 'false' | 'true' | undefined;\n    /**\n     * Indicates what notifications the user agent will trigger when the accessibility tree within a live region is modified.\n     * @see aria-atomic.\n     */\n    'aria-relevant'?: 'additions' | 'additions removals' | 'additions text' | 'all' | 'removals' | 'removals additions' | 'removals text' | 'text' | 'text additions' | 'text removals' | undefined;\n    /** Indicates that user input is required on the element before a form may be submitted. */\n    'aria-required'?: boolean | 'false' | 'true' | undefined;\n    /** Defines a human-readable, author-localized description for the role of an element. */\n    'aria-roledescription'?: string | undefined;\n    /**\n     * Defines the total number of rows in a table, grid, or treegrid.\n     * @see aria-rowindex.\n     */\n    'aria-rowcount'?: number | undefined;\n    /**\n     * Defines an element's row index or position with respect to the total number of rows within a table, grid, or treegrid.\n     * @see aria-rowcount @see aria-rowspan.\n     */\n    'aria-rowindex'?: number | undefined;\n    /**\n     * Defines the number of rows spanned by a cell or gridcell within a table, grid, or treegrid.\n     * @see aria-rowindex @see aria-colspan.\n     */\n    'aria-rowspan'?: number | undefined;\n    /**\n     * Indicates the current \"selected\" state of various widgets.\n     * @see aria-checked @see aria-pressed.\n     */\n    'aria-selected'?: boolean | 'false' | 'true' | undefined;\n    /**\n     * Defines the number of items in the current set of listitems or treeitems. Not required if all elements in the set are present in the DOM.\n     * @see aria-posinset.\n     */\n    'aria-setsize'?: number | undefined;\n    /** Indicates if items in a table or grid are sorted in ascending or descending order. */\n    'aria-sort'?: 'none' | 'ascending' | 'descending' | 'other' | undefined;\n    /** Defines the maximum allowed value for a range widget. */\n    'aria-valuemax'?: number | undefined;\n    /** Defines the minimum allowed value for a range widget. */\n    'aria-valuemin'?: number | undefined;\n    /**\n     * Defines the current value for a range widget.\n     * @see aria-valuetext.\n     */\n    'aria-valuenow'?: number | undefined;\n    /** Defines the human readable text alternative of aria-valuenow for a range widget. */\n    'aria-valuetext'?: string | undefined;\n}\n\n// All the WAI-ARIA 1.1 role attribute values from https://www.w3.org/TR/wai-aria-1.1/#role_definitions\nexport type AriaRole =\n    | 'alert'\n    | 'alertdialog'\n    | 'application'\n    | 'article'\n    | 'banner'\n    | 'button'\n    | 'cell'\n    | 'checkbox'\n    | 'columnheader'\n    | 'combobox'\n    | 'complementary'\n    | 'contentinfo'\n    | 'definition'\n    | 'dialog'\n    | 'directory'\n    | 'document'\n    | 'feed'\n    | 'figure'\n    | 'form'\n    | 'grid'\n    | 'gridcell'\n    | 'group'\n    | 'heading'\n    | 'img'\n    | 'link'\n    | 'list'\n    | 'listbox'\n    | 'listitem'\n    | 'log'\n    | 'main'\n    | 'marquee'\n    | 'math'\n    | 'menu'\n    | 'menubar'\n    | 'menuitem'\n    | 'menuitemcheckbox'\n    | 'menuitemradio'\n    | 'navigation'\n    | 'none'\n    | 'note'\n    | 'option'\n    | 'presentation'\n    | 'progressbar'\n    | 'radio'\n    | 'radiogroup'\n    | 'region'\n    | 'row'\n    | 'rowgroup'\n    | 'rowheader'\n    | 'scrollbar'\n    | 'search'\n    | 'searchbox'\n    | 'separator'\n    | 'slider'\n    | 'spinbutton'\n    | 'status'\n    | 'switch'\n    | 'tab'\n    | 'table'\n    | 'tablist'\n    | 'tabpanel'\n    | 'term'\n    | 'textbox'\n    | 'timer'\n    | 'toolbar'\n    | 'tooltip'\n    | 'tree'\n    | 'treegrid'\n    | 'treeitem'\n    | (string & {});\n\nexport interface HTMLAttributes extends AriaAttributes {\n    accessKey?: string | undefined;\n    class?: string | undefined;\n    contentEditable?: boolean | 'true' | 'false' | 'inherit' | undefined;\n    contextMenu?: string | undefined;\n    dir?: string | undefined;\n    draggable?: boolean | 'true' | 'false' | undefined;\n    hidden?: boolean | undefined;\n    id?: string | undefined;\n    lang?: string | undefined;\n    placeholder?: string | undefined;\n    slot?: string | undefined;\n    spellCheck?: boolean | 'true' | 'false' | undefined;\n    style?: string | undefined;\n    tabIndex?: number | undefined;\n    title?: string | undefined;\n    translate?: 'yes' | 'no' | undefined;\n\n    // Unknown\n    radioGroup?: string | undefined; // <command>, <menuitem>\n\n    // WAI-ARIA\n    role?: AriaRole | undefined;\n\n    // RDFa Attributes\n    about?: string | undefined;\n    datatype?: string | undefined;\n    inlist?: '';\n    prefix?: string | undefined;\n    property?: string | undefined;\n    resource?: string | undefined;\n    typeof?: string | undefined;\n    vocab?: string | undefined;\n\n    // Non-standard Attributes\n    autoCapitalize?: string | undefined;\n    autoCorrect?: string | undefined;\n    autoSave?: string | undefined;\n    color?: string | undefined;\n    itemProp?: string | undefined;\n    itemScope?: boolean | undefined;\n    itemType?: string | undefined;\n    itemID?: string | undefined;\n    itemRef?: string | undefined;\n    results?: number | undefined;\n    security?: string | undefined;\n    unselectable?: 'on' | 'off' | undefined;\n\n    // Living Standard\n    /**\n     * Hints at the type of data that might be entered by the user while editing the element or its contents\n     * @see https://html.spec.whatwg.org/multipage/interaction.html#input-modalities:-the-inputmode-attribute\n     */\n    inputMode?: 'none' | 'text' | 'tel' | 'url' | 'email' | 'numeric' | 'decimal' | 'search' | undefined;\n    /**\n     * Specify that a standard HTML element should behave like a defined custom built-in element\n     * @see https://html.spec.whatwg.org/multipage/custom-elements.html#attr-is\n     */\n    is?: string | undefined;\n}\n\nexport type HTMLAttributeReferrerPolicy = ''\n    | 'no-referrer'\n    | 'no-referrer-when-downgrade'\n    | 'origin'\n    | 'origin-when-cross-origin'\n    | 'same-origin'\n    | 'strict-origin'\n    | 'strict-origin-when-cross-origin'\n    | 'unsafe-url';\n\nexport interface AnchorHTMLAttributes extends HTMLAttributes {\n    download?: string;\n    href?: string | undefined;\n    hrefLang?: string | undefined;\n    media?: string | undefined;\n    ping?: string | undefined;\n    rel?: string | undefined;\n    target?: '_self' | '_blank' | '_parent' | '_top' | string | undefined;\n    type?: string | undefined;\n    referrerPolicy?: HTMLAttributeReferrerPolicy | undefined;\n}\n\nexport interface AreaHTMLAttributes extends HTMLAttributes {\n    alt?: string | undefined;\n    coords?: string | undefined;\n    download?: string | undefined;\n    href?: string | undefined;\n    hrefLang?: string | undefined;\n    media?: string | undefined;\n    referrerPolicy?: HTMLAttributeReferrerPolicy | undefined;\n    rel?: string | undefined;\n    shape?: string | undefined;\n    target?: string | undefined;\n}\n\nexport interface BaseHTMLAttributes extends HTMLAttributes {\n    href?: string | undefined;\n    target?: string | undefined;\n}\n\nexport interface BlockquoteHTMLAttributes extends HTMLAttributes {\n    cite?: string | undefined;\n}\n\nexport interface ButtonHTMLAttributes extends HTMLAttributes {\n    autoFocus?: boolean | undefined;\n    disabled?: boolean | undefined;\n    form?: string | undefined;\n    formAction?: string | undefined;\n    formEncType?: string | undefined;\n    formMethod?: string | undefined;\n    formNoValidate?: boolean | undefined;\n    formTarget?: string | undefined;\n    name?: string | undefined;\n    type?: 'submit' | 'reset' | 'button' | undefined;\n    value?: string | ReadonlyArray<string> | number | undefined;\n}\n\nexport interface CanvasHTMLAttributes extends HTMLAttributes {\n    height?: number | string | undefined;\n    width?: number | string | undefined;\n}\n\nexport interface ColHTMLAttributes extends HTMLAttributes {\n    span?: number | undefined;\n    width?: number | string | undefined;\n}\n\nexport interface ColgroupHTMLAttributes extends HTMLAttributes {\n    span?: number | undefined;\n}\n\nexport interface DataHTMLAttributes extends HTMLAttributes {\n    value?: string | ReadonlyArray<string> | number | undefined;\n}\n\nexport interface DetailsHTMLAttributes extends HTMLAttributes {\n    open?: boolean | undefined;\n}\n\nexport interface DelHTMLAttributes extends HTMLAttributes {\n    cite?: string | undefined;\n    dateTime?: string | undefined;\n}\n\nexport interface DialogHTMLAttributes extends HTMLAttributes {\n    open?: boolean | undefined;\n}\n\nexport interface EmbedHTMLAttributes extends HTMLAttributes {\n    height?: number | string | undefined;\n    src?: string | undefined;\n    type?: string | undefined;\n    width?: number | string | undefined;\n}\n\nexport interface FieldsetHTMLAttributes extends HTMLAttributes {\n    disabled?: boolean | undefined;\n    form?: string | undefined;\n    name?: string | undefined;\n}\n\nexport interface FormHTMLAttributes extends HTMLAttributes {\n    acceptCharset?: string | undefined;\n    action?: string | undefined;\n    autoComplete?: string | undefined;\n    encType?: string | undefined;\n    method?: string | undefined;\n    name?: string | undefined;\n    noValidate?: boolean | undefined;\n    target?: string | undefined;\n}\n\nexport interface HtmlHTMLAttributes extends HTMLAttributes {\n    manifest?: string | undefined;\n}\n\nexport interface IframeHTMLAttributes extends HTMLAttributes {\n    allow?: string | undefined;\n    allowFullScreen?: boolean | undefined;\n    allowTransparency?: boolean | undefined;\n    /** @deprecated */\n    frameBorder?: number | string | undefined;\n    height?: number | string | undefined;\n    loading?: 'eager' | 'lazy' | undefined;\n    /** @deprecated */\n    marginHeight?: number | undefined;\n    /** @deprecated */\n    marginWidth?: number | undefined;\n    name?: string | undefined;\n    referrerPolicy?: HTMLAttributeReferrerPolicy | undefined;\n    sandbox?: string | undefined;\n    /** @deprecated */\n    scrolling?: string | undefined;\n    seamless?: boolean | undefined;\n    src?: string | undefined;\n    srcDoc?: string | undefined;\n    width?: number | string | undefined;\n}\n\nexport interface ImgHTMLAttributes extends HTMLAttributes {\n    alt?: string | undefined;\n    crossOrigin?: 'anonymous' | 'use-credentials' | '' | undefined;\n    decoding?: 'async' | 'auto' | 'sync' | undefined;\n    height?: number | string | undefined;\n    loading?: 'eager' | 'lazy' | undefined;\n    referrerPolicy?: HTMLAttributeReferrerPolicy | undefined;\n    sizes?: string | undefined;\n    src?: string | undefined;\n    srcSet?: string | undefined;\n    useMap?: string | undefined;\n    width?: number | string | undefined;\n}\n\nexport interface InputHTMLAttributes extends HTMLAttributes {\n    accept?: string | undefined;\n    alt?: string | undefined;\n    autoComplete?: string | undefined;\n    autoFocus?: boolean | undefined;\n    capture?: boolean | string | undefined; // https://www.w3.org/TR/html-media-capture/#the-capture-attribute\n    checked?: boolean | undefined;\n    crossOrigin?: string | undefined;\n    disabled?: boolean | undefined;\n    form?: string | undefined;\n    formAction?: string | undefined;\n    formEncType?: string | undefined;\n    formMethod?: string | undefined;\n    formNoValidate?: boolean | undefined;\n    formTarget?: string | undefined;\n    height?: number | string | undefined;\n    list?: string | undefined;\n    max?: number | string | undefined;\n    maxLength?: number | undefined;\n    min?: number | string | undefined;\n    minLength?: number | undefined;\n    multiple?: boolean | undefined;\n    name?: string | undefined;\n    pattern?: string | undefined;\n    placeholder?: string | undefined;\n    readOnly?: boolean | undefined;\n    required?: boolean | undefined;\n    size?: number | undefined;\n    src?: string | undefined;\n    step?: number | string | undefined;\n    type?: string | undefined;\n    value?: string | ReadonlyArray<string> | number | undefined;\n    width?: number | string | undefined;\n}\n\nexport interface InsHTMLAttributes extends HTMLAttributes {\n    cite?: string | undefined;\n    dateTime?: string | undefined;\n}\n\nexport interface KeygenHTMLAttributes extends HTMLAttributes {\n    autoFocus?: boolean | undefined;\n    challenge?: string | undefined;\n    disabled?: boolean | undefined;\n    form?: string | undefined;\n    keyType?: string | undefined;\n    keyParams?: string | undefined;\n    name?: string | undefined;\n}\n\nexport interface LabelHTMLAttributes extends HTMLAttributes {\n    form?: string | undefined;\n    for?: string | undefined;\n}\n\nexport interface LiHTMLAttributes extends HTMLAttributes {\n    value?: string | ReadonlyArray<string> | number | undefined;\n}\n\nexport interface LinkHTMLAttributes extends HTMLAttributes {\n    as?: string | undefined;\n    crossOrigin?: string | undefined;\n    href?: string | undefined;\n    hrefLang?: string | undefined;\n    integrity?: string | undefined;\n    media?: string | undefined;\n    referrerPolicy?: HTMLAttributeReferrerPolicy | undefined;\n    rel?: string | undefined;\n    sizes?: string | undefined;\n    type?: string | undefined;\n    charSet?: string | undefined;\n}\n\nexport interface MapHTMLAttributes extends HTMLAttributes {\n    name?: string | undefined;\n}\n\nexport interface MenuHTMLAttributes extends HTMLAttributes {\n    type?: string | undefined;\n}\n\nexport interface MediaHTMLAttributes extends HTMLAttributes {\n    autoPlay?: boolean | undefined;\n    controls?: boolean | undefined;\n    controlsList?: string | undefined;\n    crossOrigin?: string | undefined;\n    loop?: boolean | undefined;\n    mediaGroup?: string | undefined;\n    muted?: boolean | undefined;\n    playsInline?: boolean | undefined;\n    preload?: string | undefined;\n    src?: string | undefined;\n}\n\nexport interface MetaHTMLAttributes extends HTMLAttributes {\n    charSet?: string | undefined;\n    content?: string | undefined;\n    httpEquiv?: string | undefined;\n    name?: string | undefined;\n    media?: string | undefined;\n}\n\nexport interface MeterHTMLAttributes extends HTMLAttributes {\n    form?: string | undefined;\n    high?: number | undefined;\n    low?: number | undefined;\n    max?: number | string | undefined;\n    min?: number | string | undefined;\n    optimum?: number | undefined;\n    value?: string | ReadonlyArray<string> | number | undefined;\n}\n\nexport interface QuoteHTMLAttributes extends HTMLAttributes {\n    cite?: string | undefined;\n}\n\nexport interface ObjectHTMLAttributes extends HTMLAttributes {\n    classID?: string | undefined;\n    data?: string | undefined;\n    form?: string | undefined;\n    height?: number | string | undefined;\n    name?: string | undefined;\n    type?: string | undefined;\n    useMap?: string | undefined;\n    width?: number | string | undefined;\n    wmode?: string | undefined;\n}\n\nexport interface OlHTMLAttributes extends HTMLAttributes {\n    reversed?: boolean | undefined;\n    start?: number | undefined;\n    type?: '1' | 'a' | 'A' | 'i' | 'I' | undefined;\n}\n\nexport interface OptgroupHTMLAttributes extends HTMLAttributes {\n    disabled?: boolean | undefined;\n    label?: string | undefined;\n}\n\nexport interface OptionHTMLAttributes extends HTMLAttributes {\n    disabled?: boolean | undefined;\n    label?: string | undefined;\n    selected?: boolean | undefined;\n    value?: string | ReadonlyArray<string> | number | undefined;\n}\n\nexport interface OutputHTMLAttributes extends HTMLAttributes {\n    form?: string | undefined;\n    for?: string | undefined;\n    name?: string | undefined;\n}\n\nexport interface ParamHTMLAttributes extends HTMLAttributes {\n    name?: string | undefined;\n    value?: string | ReadonlyArray<string> | number | undefined;\n}\n\nexport interface ProgressHTMLAttributes extends HTMLAttributes {\n    max?: number | string | undefined;\n    value?: string | ReadonlyArray<string> | number | undefined;\n}\n\nexport interface SlotHTMLAttributes extends HTMLAttributes {\n    name?: string | undefined;\n}\n\nexport interface ScriptHTMLAttributes extends HTMLAttributes {\n    async?: boolean | undefined;\n    /** @deprecated */\n    charSet?: string | undefined;\n    crossOrigin?: string | undefined;\n    defer?: boolean | undefined;\n    integrity?: string | undefined;\n    noModule?: boolean | undefined;\n    nonce?: string | undefined;\n    referrerPolicy?: HTMLAttributeReferrerPolicy | undefined;\n    src?: string | undefined;\n    type?: string | undefined;\n}\n\nexport interface SelectHTMLAttributes extends HTMLAttributes {\n    autoComplete?: string | undefined;\n    autoFocus?: boolean | undefined;\n    disabled?: boolean | undefined;\n    form?: string | undefined;\n    multiple?: boolean | undefined;\n    name?: string | undefined;\n    required?: boolean | undefined;\n    size?: number | undefined;\n    value?: string | ReadonlyArray<string> | number | undefined;\n}\n\nexport interface SourceHTMLAttributes extends HTMLAttributes {\n    height?: number | string | undefined;\n    media?: string | undefined;\n    sizes?: string | undefined;\n    src?: string | undefined;\n    srcSet?: string | undefined;\n    type?: string | undefined;\n    width?: number | string | undefined;\n}\n\nexport interface StyleHTMLAttributes extends HTMLAttributes {\n    media?: string | undefined;\n    nonce?: string | undefined;\n    scoped?: boolean | undefined;\n    type?: string | undefined;\n}\n\nexport interface TableHTMLAttributes extends HTMLAttributes {\n    cellPadding?: number | string | undefined;\n    cellSpacing?: number | string | undefined;\n    summary?: string | undefined;\n    width?: number | string | undefined;\n}\n\nexport interface TextareaHTMLAttributes extends HTMLAttributes {\n    autoComplete?: string | undefined;\n    autoFocus?: boolean | undefined;\n    cols?: number | undefined;\n    dirName?: string | undefined;\n    disabled?: boolean | undefined;\n    form?: string | undefined;\n    maxLength?: number | undefined;\n    minLength?: number | undefined;\n    name?: string | undefined;\n    placeholder?: string | undefined;\n    readOnly?: boolean | undefined;\n    required?: boolean | undefined;\n    rows?: number | undefined;\n    value?: string | ReadonlyArray<string> | number | undefined;\n    wrap?: string | undefined;\n}\n\nexport interface TdHTMLAttributes extends HTMLAttributes {\n    align?: 'left' | 'center' | 'right' | 'justify' | 'char' | undefined;\n    colSpan?: number | undefined;\n    headers?: string | undefined;\n    rowSpan?: number | undefined;\n    scope?: string | undefined;\n    abbr?: string | undefined;\n    height?: number | string | undefined;\n    width?: number | string | undefined;\n    valign?: 'top' | 'middle' | 'bottom' | 'baseline' | undefined;\n}\n\nexport interface ThHTMLAttributes extends HTMLAttributes {\n    align?: 'left' | 'center' | 'right' | 'justify' | 'char' | undefined;\n    colSpan?: number | undefined;\n    headers?: string | undefined;\n    rowSpan?: number | undefined;\n    scope?: string | undefined;\n    abbr?: string | undefined;\n}\n\nexport interface TimeHTMLAttributes extends HTMLAttributes {\n    dateTime?: string | undefined;\n}\n\nexport interface TrackHTMLAttributes extends HTMLAttributes {\n    default?: boolean | undefined;\n    kind?: string | undefined;\n    label?: string | undefined;\n    src?: string | undefined;\n    srcLang?: string | undefined;\n}\n\nexport interface VideoHTMLAttributes extends MediaHTMLAttributes {\n    height?: number | string | undefined;\n    playsInline?: boolean | undefined;\n    poster?: string | undefined;\n    width?: number | string | undefined;\n    disablePictureInPicture?: boolean | undefined;\n}\n\nexport interface SVGAttributes extends AriaAttributes {\n    // Attributes which also defined in HTMLAttributes\n    // See comment in SVGDOMPropertyConfig.js\n    class?: string | undefined;\n    color?: string | undefined;\n    height?: number | string | undefined;\n    id?: string | undefined;\n    lang?: string | undefined;\n    max?: number | string | undefined;\n    media?: string | undefined;\n    method?: string | undefined;\n    min?: number | string | undefined;\n    name?: string | undefined;\n    style?: string | undefined;\n    target?: string | undefined;\n    type?: string | undefined;\n    width?: number | string | undefined;\n\n    // Other HTML properties supported by SVG elements in browsers\n    role?: AriaRole | undefined;\n    tabIndex?: number | undefined;\n    crossOrigin?: 'anonymous' | 'use-credentials' | '' | undefined;\n\n    // SVG Specific attributes\n    accentHeight?: number | string | undefined;\n    accumulate?: 'none' | 'sum' | undefined;\n    additive?: 'replace' | 'sum' | undefined;\n    alignmentBaseline?: 'auto' | 'baseline' | 'before-edge' | 'text-before-edge' | 'middle' | 'central' | 'after-edge' |\n    'text-after-edge' | 'ideographic' | 'alphabetic' | 'hanging' | 'mathematical' | 'inherit' | undefined;\n    allowReorder?: 'no' | 'yes' | undefined;\n    alphabetic?: number | string | undefined;\n    amplitude?: number | string | undefined;\n    arabicForm?: 'initial' | 'medial' | 'terminal' | 'isolated' | undefined;\n    ascent?: number | string | undefined;\n    attributeName?: string | undefined;\n    attributeType?: string | undefined;\n    autoReverse?: 'true' | 'false' | boolean | undefined;\n    azimuth?: number | string | undefined;\n    baseFrequency?: number | string | undefined;\n    baselineShift?: number | string | undefined;\n    baseProfile?: number | string | undefined;\n    bbox?: number | string | undefined;\n    begin?: number | string | undefined;\n    bias?: number | string | undefined;\n    by?: number | string | undefined;\n    calcMode?: number | string | undefined;\n    capHeight?: number | string | undefined;\n    clip?: number | string | undefined;\n    clipPath?: string | undefined;\n    clipPathUnits?: number | string | undefined;\n    clipRule?: number | string | undefined;\n    colorInterpolation?: number | string | undefined;\n    colorInterpolationFilters?: 'auto' | 'sRGB' | 'linearRGB' | 'inherit' | undefined;\n    colorProfile?: number | string | undefined;\n    colorRendering?: number | string | undefined;\n    contentScriptType?: number | string | undefined;\n    contentStyleType?: number | string | undefined;\n    cursor?: number | string | undefined;\n    cx?: number | string | undefined;\n    cy?: number | string | undefined;\n    d?: string | undefined;\n    decelerate?: number | string | undefined;\n    descent?: number | string | undefined;\n    diffuseConstant?: number | string | undefined;\n    direction?: number | string | undefined;\n    display?: number | string | undefined;\n    divisor?: number | string | undefined;\n    dominantBaseline?: number | string | undefined;\n    dur?: number | string | undefined;\n    dx?: number | string | undefined;\n    dy?: number | string | undefined;\n    edgeMode?: number | string | undefined;\n    elevation?: number | string | undefined;\n    enableBackground?: number | string | undefined;\n    end?: number | string | undefined;\n    exponent?: number | string | undefined;\n    externalResourcesRequired?: 'true' | 'false' | boolean | undefined;\n    fill?: string | undefined;\n    fillOpacity?: number | string | undefined;\n    fillRule?: 'nonzero' | 'evenodd' | 'inherit' | undefined;\n    filter?: string | undefined;\n    filterRes?: number | string | undefined;\n    filterUnits?: number | string | undefined;\n    floodColor?: number | string | undefined;\n    floodOpacity?: number | string | undefined;\n    focusable?: 'true' | 'false' | boolean | 'auto' | undefined;\n    fontFamily?: string | undefined;\n    fontSize?: number | string | undefined;\n    fontSizeAdjust?: number | string | undefined;\n    fontStretch?: number | string | undefined;\n    fontStyle?: number | string | undefined;\n    fontVariant?: number | string | undefined;\n    fontWeight?: number | string | undefined;\n    format?: number | string | undefined;\n    from?: number | string | undefined;\n    fx?: number | string | undefined;\n    fy?: number | string | undefined;\n    g1?: number | string | undefined;\n    g2?: number | string | undefined;\n    glyphName?: number | string | undefined;\n    glyphOrientationHorizontal?: number | string | undefined;\n    glyphOrientationVertical?: number | string | undefined;\n    glyphRef?: number | string | undefined;\n    gradientTransform?: string | undefined;\n    gradientUnits?: string | undefined;\n    hanging?: number | string | undefined;\n    horizAdvX?: number | string | undefined;\n    horizOriginX?: number | string | undefined;\n    href?: string | undefined;\n    ideographic?: number | string | undefined;\n    imageRendering?: number | string | undefined;\n    in2?: number | string | undefined;\n    in?: string | undefined;\n    intercept?: number | string | undefined;\n    k1?: number | string | undefined;\n    k2?: number | string | undefined;\n    k3?: number | string | undefined;\n    k4?: number | string | undefined;\n    k?: number | string | undefined;\n    kernelMatrix?: number | string | undefined;\n    kernelUnitLength?: number | string | undefined;\n    kerning?: number | string | undefined;\n    keyPoints?: number | string | undefined;\n    keySplines?: number | string | undefined;\n    keyTimes?: number | string | undefined;\n    lengthAdjust?: number | string | undefined;\n    letterSpacing?: number | string | undefined;\n    lightingColor?: number | string | undefined;\n    limitingConeAngle?: number | string | undefined;\n    local?: number | string | undefined;\n    markerEnd?: string | undefined;\n    markerHeight?: number | string | undefined;\n    markerMid?: string | undefined;\n    markerStart?: string | undefined;\n    markerUnits?: number | string | undefined;\n    markerWidth?: number | string | undefined;\n    mask?: string | undefined;\n    maskContentUnits?: number | string | undefined;\n    maskUnits?: number | string | undefined;\n    mathematical?: number | string | undefined;\n    mode?: number | string | undefined;\n    numOctaves?: number | string | undefined;\n    offset?: number | string | undefined;\n    opacity?: number | string | undefined;\n    operator?: number | string | undefined;\n    order?: number | string | undefined;\n    orient?: number | string | undefined;\n    orientation?: number | string | undefined;\n    origin?: number | string | undefined;\n    overflow?: number | string | undefined;\n    overlinePosition?: number | string | undefined;\n    overlineThickness?: number | string | undefined;\n    paintOrder?: number | string | undefined;\n    panose1?: number | string | undefined;\n    path?: string | undefined;\n    pathLength?: number | string | undefined;\n    patternContentUnits?: string | undefined;\n    patternTransform?: number | string | undefined;\n    patternUnits?: string | undefined;\n    pointerEvents?: number | string | undefined;\n    points?: string | undefined;\n    pointsAtX?: number | string | undefined;\n    pointsAtY?: number | string | undefined;\n    pointsAtZ?: number | string | undefined;\n    preserveAlpha?: 'true' | 'false' | boolean | undefined;\n    preserveAspectRatio?: string | undefined;\n    primitiveUnits?: number | string | undefined;\n    r?: number | string | undefined;\n    radius?: number | string | undefined;\n    refX?: number | string | undefined;\n    refY?: number | string | undefined;\n    renderingIntent?: number | string | undefined;\n    repeatCount?: number | string | undefined;\n    repeatDur?: number | string | undefined;\n    requiredExtensions?: number | string | undefined;\n    requiredFeatures?: number | string | undefined;\n    restart?: number | string | undefined;\n    result?: string | undefined;\n    rotate?: number | string | undefined;\n    rx?: number | string | undefined;\n    ry?: number | string | undefined;\n    scale?: number | string | undefined;\n    seed?: number | string | undefined;\n    shapeRendering?: number | string | undefined;\n    slope?: number | string | undefined;\n    spacing?: number | string | undefined;\n    specularConstant?: number | string | undefined;\n    specularExponent?: number | string | undefined;\n    speed?: number | string | undefined;\n    spreadMethod?: string | undefined;\n    startOffset?: number | string | undefined;\n    stdDeviation?: number | string | undefined;\n    stemh?: number | string | undefined;\n    stemv?: number | string | undefined;\n    stitchTiles?: number | string | undefined;\n    stopColor?: string | undefined;\n    stopOpacity?: number | string | undefined;\n    strikethroughPosition?: number | string | undefined;\n    strikethroughThickness?: number | string | undefined;\n    string?: number | string | undefined;\n    stroke?: string | undefined;\n    strokeDasharray?: string | number | undefined;\n    strokeDashoffset?: string | number | undefined;\n    strokeLinecap?: 'butt' | 'round' | 'square' | 'inherit' | undefined;\n    strokeLinejoin?: 'miter' | 'round' | 'bevel' | 'inherit' | undefined;\n    strokeMiterlimit?: number | string | undefined;\n    strokeOpacity?: number | string | undefined;\n    strokeWidth?: number | string | undefined;\n    surfaceScale?: number | string | undefined;\n    systemLanguage?: number | string | undefined;\n    tableValues?: number | string | undefined;\n    targetX?: number | string | undefined;\n    targetY?: number | string | undefined;\n    textAnchor?: string | undefined;\n    textDecoration?: number | string | undefined;\n    textLength?: number | string | undefined;\n    textRendering?: number | string | undefined;\n    to?: number | string | undefined;\n    transform?: string | undefined;\n    u1?: number | string | undefined;\n    u2?: number | string | undefined;\n    underlinePosition?: number | string | undefined;\n    underlineThickness?: number | string | undefined;\n    unicode?: number | string | undefined;\n    unicodeBidi?: number | string | undefined;\n    unicodeRange?: number | string | undefined;\n    unitsPerEm?: number | string | undefined;\n    vAlphabetic?: number | string | undefined;\n    values?: string | undefined;\n    vectorEffect?: number | string | undefined;\n    version?: string | undefined;\n    vertAdvY?: number | string | undefined;\n    vertOriginX?: number | string | undefined;\n    vertOriginY?: number | string | undefined;\n    vHanging?: number | string | undefined;\n    vIdeographic?: number | string | undefined;\n    viewBox?: string | undefined;\n    viewTarget?: number | string | undefined;\n    visibility?: number | string | undefined;\n    vMathematical?: number | string | undefined;\n    widths?: number | string | undefined;\n    wordSpacing?: number | string | undefined;\n    writingMode?: number | string | undefined;\n    x1?: number | string | undefined;\n    x2?: number | string | undefined;\n    x?: number | string | undefined;\n    xChannelSelector?: string | undefined;\n    xHeight?: number | string | undefined;\n    xlinkActuate?: string | undefined;\n    xlinkArcrole?: string | undefined;\n    xlinkHref?: string | undefined;\n    xlinkRole?: string | undefined;\n    xlinkShow?: string | undefined;\n    xlinkTitle?: string | undefined;\n    xlinkType?: string | undefined;\n    xmlBase?: string | undefined;\n    xmlLang?: string | undefined;\n    xmlns?: string | undefined;\n    xmlnsXlink?: string | undefined;\n    xmlSpace?: string | undefined;\n    y1?: number | string | undefined;\n    y2?: number | string | undefined;\n    y?: number | string | undefined;\n    yChannelSelector?: string | undefined;\n    z?: number | string | undefined;\n    zoomAndPan?: string | undefined;\n}\n\nexport type AttributesMap = {\n    [K in keyof HTMLTagNameMap]:\n        K extends 'a' ? AnchorHTMLAttributes :\n        K extends 'area' ? AreaHTMLAttributes :\n        K extends 'audio' ? MediaHTMLAttributes :\n        K extends 'base' ? BaseHTMLAttributes :\n        K extends 'blockquote' ? BlockquoteHTMLAttributes :\n        K extends 'button' ? ButtonHTMLAttributes :\n        K extends 'canvase' ? CanvasHTMLAttributes :\n        K extends 'col' ? ColHTMLAttributes :\n        K extends 'colgroup' ? ColgroupHTMLAttributes :\n        K extends 'data' ? DataHTMLAttributes :\n        K extends 'del' ? DelHTMLAttributes :\n        K extends 'details' ? DetailsHTMLAttributes :\n        K extends 'dialog' ? DialogHTMLAttributes :\n        K extends 'embed' ? EmbedHTMLAttributes :\n        K extends 'fieldset' ? FieldsetHTMLAttributes :\n        K extends 'form' ? FormHTMLAttributes :\n        K extends 'html' ? HtmlHTMLAttributes :\n        K extends 'iframe' ? IframeHTMLAttributes :\n        K extends 'img' ? ImgHTMLAttributes :\n        K extends 'input' ? InputHTMLAttributes :\n        K extends 'ins' ? InsHTMLAttributes :\n        K extends 'keygen' ? KeygenHTMLAttributes :\n        K extends 'label' ? LabelHTMLAttributes :\n        K extends 'li' ? LiHTMLAttributes :\n        K extends 'link' ? LinkHTMLAttributes :\n        K extends 'map' ? MapHTMLAttributes :\n        K extends 'menu' ? MenuHTMLAttributes :\n        K extends 'meta' ? MetaHTMLAttributes :\n        K extends 'meter' ? MeterHTMLAttributes :\n        K extends 'object' ? ObjectHTMLAttributes :\n        K extends 'ol' ? OlHTMLAttributes :\n        K extends 'optgroup' ? OptgroupHTMLAttributes :\n        K extends 'option' ? OptionHTMLAttributes :\n        K extends 'output' ? OutputHTMLAttributes :\n        K extends 'param' ? ParamHTMLAttributes :\n        K extends 'progress' ? ProgressHTMLAttributes :\n        K extends 'quote' ? QuoteHTMLAttributes :\n        K extends 'slot' ? SlotHTMLAttributes :\n        K extends 'script' ? ScriptHTMLAttributes :\n        K extends 'select' ? SelectHTMLAttributes :\n        K extends 'source' ? SourceHTMLAttributes :\n        K extends 'style' ? StyleHTMLAttributes :\n        K extends 'table' ? TableHTMLAttributes :\n        K extends 'td' ? TdHTMLAttributes :\n        K extends 'textarea' ? TextareaHTMLAttributes :\n        K extends 'th' ? ThHTMLAttributes :\n        K extends 'time' ? TimeHTMLAttributes :\n        K extends 'track' ? TrackHTMLAttributes :\n        K extends 'video' ? VideoHTMLAttributes :\n        K extends 'svg' ? SVGAttributes :\n        HTMLAttributes;\n} & {\n    'big': HTMLAttributes;\n    'keygen': HTMLAttributes;\n    'menuitem': HTMLAttributes;\n    'noindex': HTMLAttributes;\n    'iframe': IframeHTMLAttributes;\n\n    'animate': SVGAttributes;\n    'animateMotion': SVGAttributes;\n    'animateTransform': SVGAttributes;\n    'circle': SVGAttributes;\n    'clipPath': SVGAttributes;\n    'defs': SVGAttributes;\n    'desc': SVGAttributes;\n    'ellipse': SVGAttributes;\n    'feBlend': SVGAttributes;\n    'feColorMatrix': SVGAttributes;\n    'feComponentTransfer': SVGAttributes;\n    'feComposite': SVGAttributes;\n    'feConvolveMatrix': SVGAttributes;\n    'feDiffuseLighting': SVGAttributes;\n    'feDisplacementMap': SVGAttributes;\n    'feDistantLight': SVGAttributes;\n    'feDropShadow': SVGAttributes;\n    'feFlood': SVGAttributes;\n    'feFuncA': SVGAttributes;\n    'feFuncB': SVGAttributes;\n    'feFuncG': SVGAttributes;\n    'feFuncR': SVGAttributes;\n    'feGaussianBlur': SVGAttributes;\n    'feImage': SVGAttributes;\n    'feMerge': SVGAttributes;\n    'feMergeNode': SVGAttributes;\n    'feMorphology': SVGAttributes;\n    'feOffset': SVGAttributes;\n    'fePointLight': SVGAttributes;\n    'feSpecularLighting': SVGAttributes;\n    'feSpotLight': SVGAttributes;\n    'feTile': SVGAttributes;\n    'feTurbulence': SVGAttributes;\n    'filter': SVGAttributes;\n    'foreignObject': SVGAttributes;\n    'g': SVGAttributes;\n    'image': SVGAttributes;\n    'line': SVGAttributes;\n    'linearGradient': SVGAttributes;\n    'marker': SVGAttributes;\n    'mask': SVGAttributes;\n    'metadata': SVGAttributes;\n    'mpath': SVGAttributes;\n    'path': SVGAttributes;\n    'pattern': SVGAttributes;\n    'polygon': SVGAttributes;\n    'polyline': SVGAttributes;\n    'radialGradient': SVGAttributes;\n    'rect': SVGAttributes;\n    'stop': SVGAttributes;\n    'svg': SVGAttributes;\n    'switch': SVGAttributes;\n    'symbol': SVGAttributes;\n    'text': SVGAttributes;\n    'textPath': SVGAttributes;\n    'tspan': SVGAttributes;\n    'use': SVGAttributes;\n    'view': SVGAttributes;\n\n    [k: string]: HTMLAttributes;\n}\n\nexport interface HTMLTagNameMap {\n    'a': HTMLAnchorElement;\n    'abbr': HTMLElement;\n    'address': HTMLElement;\n    'area': HTMLAreaElement;\n    'article': HTMLElement;\n    'aside': HTMLElement;\n    'audio': HTMLAudioElement;\n    'b': HTMLElement;\n    'base': HTMLBaseElement;\n    'bdi': HTMLElement;\n    'bdo': HTMLElement;\n    'blockquote': HTMLQuoteElement;\n    'body': HTMLBodyElement;\n    'br': HTMLBRElement;\n    'button': HTMLButtonElement;\n    'canvas': HTMLCanvasElement;\n    'caption': HTMLTableCaptionElement;\n    'cite': HTMLElement;\n    'code': HTMLElement;\n    'col': HTMLTableColElement;\n    'colgroup': HTMLTableColElement;\n    'data': HTMLDataElement;\n    'datalist': HTMLDataListElement;\n    'dd': HTMLElement;\n    'del': HTMLModElement;\n    'details': HTMLDetailsElement;\n    'dfn': HTMLElement;\n    'dialog': HTMLDialogElement;\n    'dir': HTMLDirectoryElement;\n    'div': HTMLDivElement;\n    'dl': HTMLDListElement;\n    'dt': HTMLElement;\n    'em': HTMLElement;\n    'embed': HTMLEmbedElement;\n    'fieldset': HTMLFieldSetElement;\n    'figcaption': HTMLElement;\n    'figure': HTMLElement;\n    'font': HTMLFontElement;\n    'footer': HTMLElement;\n    'form': HTMLFormElement;\n    'frame': HTMLFrameElement;\n    'frameset': HTMLFrameSetElement;\n    'h1': HTMLHeadingElement;\n    'h2': HTMLHeadingElement;\n    'h3': HTMLHeadingElement;\n    'h4': HTMLHeadingElement;\n    'h5': HTMLHeadingElement;\n    'h6': HTMLHeadingElement;\n    'head': HTMLHeadElement;\n    'header': HTMLElement;\n    'hgroup': HTMLElement;\n    'hr': HTMLHRElement;\n    'html': HTMLHtmlElement;\n    'i': HTMLElement;\n    'iframe': HTMLIFrameElement;\n    'img': HTMLImageElement;\n    'input': HTMLInputElement;\n    'ins': HTMLModElement;\n    'kbd': HTMLElement;\n    'label': HTMLLabelElement;\n    'legend': HTMLLegendElement;\n    'li': HTMLLIElement;\n    'link': HTMLLinkElement;\n    'main': HTMLElement;\n    'map': HTMLMapElement;\n    'mark': HTMLElement;\n    'marquee': HTMLMarqueeElement;\n    'menu': HTMLMenuElement;\n    'meta': HTMLMetaElement;\n    'meter': HTMLMeterElement;\n    'nav': HTMLElement;\n    'noscript': HTMLElement;\n    'object': HTMLObjectElement;\n    'ol': HTMLOListElement;\n    'optgroup': HTMLOptGroupElement;\n    'option': HTMLOptionElement;\n    'output': HTMLOutputElement;\n    'p': HTMLParagraphElement;\n    'param': HTMLParamElement;\n    'picture': HTMLPictureElement;\n    'pre': HTMLPreElement;\n    'progress': HTMLProgressElement;\n    'q': HTMLQuoteElement;\n    'rp': HTMLElement;\n    'rt': HTMLElement;\n    'ruby': HTMLElement;\n    's': HTMLElement;\n    'samp': HTMLElement;\n    'script': HTMLScriptElement;\n    'section': HTMLElement;\n    'select': HTMLSelectElement;\n    'slot': HTMLSlotElement;\n    'small': HTMLElement;\n    'source': HTMLSourceElement;\n    'span': HTMLSpanElement;\n    'strong': HTMLElement;\n    'style': HTMLStyleElement;\n    'sub': HTMLElement;\n    'summary': HTMLElement;\n    'sup': HTMLElement;\n    'table': HTMLTableElement;\n    'tbody': HTMLTableSectionElement;\n    'td': HTMLTableCellElement;\n    'template': HTMLTemplateElement;\n    'textarea': HTMLTextAreaElement;\n    'tfoot': HTMLTableSectionElement;\n    'th': HTMLTableCellElement;\n    'thead': HTMLTableSectionElement;\n    'time': HTMLTimeElement;\n    'title': HTMLTitleElement;\n    'tr': HTMLTableRowElement;\n    'track': HTMLTrackElement;\n    'u': HTMLElement;\n    'ul': HTMLUListElement;\n    'var': HTMLElement;\n    'video': HTMLVideoElement;\n    'wbr': HTMLElement;\n    'big': HTMLElement;\n    'keygen': HTMLElement;\n    'menuitem': HTMLElement;\n    'noindex': HTMLElement;\n}\n\nexport interface SVGTagNameMap {\n    'animate': SVGElement;\n    'animateMotion': SVGElement;\n    'animateTransform': SVGElement;\n    'circle': SVGCircleElement;\n    'clipPath': SVGClipPathElement;\n    'defs': SVGDefsElement;\n    'desc': SVGDescElement;\n    'ellipse': SVGEllipseElement;\n    'feBlend': SVGFEBlendElement;\n    'feColorMatrix': SVGFEColorMatrixElement;\n    'feComponentTransfer': SVGFEComponentTransferElement;\n    'feComposite': SVGFECompositeElement;\n    'feConvolveMatrix': SVGFEConvolveMatrixElement;\n    'feDiffuseLighting': SVGFEDiffuseLightingElement;\n    'feDisplacementMap': SVGFEDisplacementMapElement;\n    'feDistantLight': SVGFEDistantLightElement;\n    'feDropShadow': SVGElement;\n    'feFlood': SVGFEFloodElement;\n    'feFuncA': SVGFEFuncAElement;\n    'feFuncB': SVGFEFuncBElement;\n    'feFuncG': SVGFEFuncGElement;\n    'feFuncR': SVGFEFuncRElement;\n    'feGaussianBlur': SVGFEGaussianBlurElement;\n    'feImage': SVGFEImageElement;\n    'feMerge': SVGFEMergeElement;\n    'feMergeNode': SVGFEMergeNodeElement;\n    'feMorphology': SVGFEMorphologyElement;\n    'feOffset': SVGFEOffsetElement;\n    'fePointLight': SVGFEPointLightElement;\n    'feSpecularLighting': SVGFESpecularLightingElement;\n    'feSpotLight': SVGFESpotLightElement;\n    'feTile': SVGFETileElement;\n    'feTurbulence': SVGFETurbulenceElement;\n    'filter': SVGFilterElement;\n    'foreignObject': SVGForeignObjectElement;\n    'g': SVGGElement;\n    'image': SVGImageElement;\n    'line': SVGLineElement;\n    'linearGradient': SVGLinearGradientElement;\n    'marker': SVGMarkerElement;\n    'mask': SVGMaskElement;\n    'metadata': SVGMetadataElement;\n    'mpath': SVGElement;\n    'path': SVGPathElement;\n    'pattern': SVGPatternElement;\n    'polygon': SVGPolygonElement;\n    'polyline': SVGPolylineElement;\n    'radialGradient': SVGRadialGradientElement;\n    'rect': SVGRectElement;\n    'stop': SVGStopElement;\n    'svg': SVGElement;\n    'switch': SVGSwitchElement;\n    'symbol': SVGSymbolElement;\n    'text': SVGTextElement;\n    'textPath': SVGTextPathElement;\n    'tspan': SVGTSpanElement;\n    'use': SVGUseElement;\n    'view': SVGViewElement;\n}\n\n/**\n * Identify virtual dom objects.\n */\nexport const V_SYM: unique symbol = Symbol();\n\n/**\n * A constructor alias used for JSX fragments </>.\n */\nexport const Fragment: unique symbol = Symbol();\n\n/**\n * Get all the property keys that extends a builtin element.\n */\nexport type ExtractCustomElementsKeys<T extends keyof HTMLTagNameMap> = Exclude<{\n    [K in keyof JSXInternal.CustomElements]:\n        'extends' extends keyof JSXInternal.CustomElements[K] ?\n            JSXInternal.CustomElements[K]['extends'] extends T ?\n                (keyof Props<JSXInternal.CustomElements[K]>) :\n                never :\n            never;\n}[keyof JSXInternal.CustomElements], never | keyof VRenderProperties | 'extends' | keyof Props<HTMLTagNameMap[T]>>;\n\n/**\n * Classes dictionary.\n */\nexport type VClasses = string\n    | { [key: string]: boolean | undefined };\n\n/**\n * Styles dictionary.\n */\nexport type VStyle = string\n    | { [key: string]: string | undefined };\n\n/**\n * Special virtual properties.\n */\nexport type VRenderProperties = {\n    is?: string;\n    slot?: string;\n    key?: unknown;\n    xmlns?: string;\n    ref?: Element;\n    children?: Template | Template[];\n    class?: VClasses;\n    style?: VStyle;\n    [listener: `on${string}`]: EventListener | undefined;\n};\n\n/**\n * Get prototype properties that can be assigned to the node.\n */\nexport type VProps<T> = Omit<\n    T extends keyof HTMLTagNameMap ? Props<HTMLTagNameMap[T]> :\n    T extends keyof SVGTagNameMap ? Props<SVGTagNameMap[T]> :\n    T extends Element ? Props<T> :\n    T extends FunctionComponent ? Parameters<T>[0] :\n    T extends string ? Props<HTMLElement> :\n    T,\n    keyof VRenderProperties\n> & (\n    T extends keyof HTMLTagNameMap ? { is?: never } & {\n        [K in ExtractCustomElementsKeys<T>]?: never;\n    } :\n    T extends keyof SVGTagNameMap ? { is?: never } :\n    T extends Element ? { is?: never } :\n    { is?: unknown }\n);\n\n/**\n * Get a list of html attributes that can be assigned to the node.\n */\nexport type VAttrs<T, E> = Omit<\n    E extends keyof HTMLTagNameMap ? AttributesMap[E] :\n    E extends keyof SVGTagNameMap ? AttributesMap[E] :\n    T extends keyof HTMLTagNameMap ? AttributesMap[T] :\n    T extends keyof SVGTagNameMap ? AttributesMap[T] :\n    T extends SVGElement ? SVGAttributes :\n    T extends Element ? HTMLAttributes :\n    T extends string ? HTMLAttributes :\n    {},\n    keyof VRenderProperties\n>;\n\n/**\n * Get all valid prototypes properties that extends a builtin element.\n */\nexport type VExtends<T> =\n    Exclude<\n        {\n            [K in keyof JSXInternal.CustomElements]:\n                'extends' extends keyof JSXInternal.CustomElements[K] ?\n                    JSXInternal.CustomElements[K]['extends'] extends T ?\n                        (\n                            { is: K }\n                            & Omit<Props<JSXInternal.CustomElements[K]>, keyof VRenderProperties | 'extends'>\n                            & VAttrs<JSXInternal.CustomElements[K], JSXInternal.CustomElements[K]['extends']>\n                            & VRenderProperties\n                        ) :\n                        never :\n                    never;\n        }[keyof JSXInternal.CustomElements],\n        never\n    >;\n\n/**\n * Properties that can be assigned to a node through the render engine.\n */\nexport type VProperties<\n    TagOrFunctionOrProps = { [key: string]: unknown },\n    Extends extends string | null = null\n> = TagOrFunctionOrProps extends string ?\n        (\n            (VProps<TagOrFunctionOrProps>\n            & VAttrs<TagOrFunctionOrProps, Extends>\n            & VRenderProperties)\n            | VExtends<TagOrFunctionOrProps>\n        ) : (\n            VProps<TagOrFunctionOrProps>\n            & VAttrs<TagOrFunctionOrProps, Extends>\n            & VRenderProperties\n        );\n\n/**\n * The interface of a JSX fragment node.\n */\nexport type VFragment = {\n    type: typeof Fragment;\n    key: unknown;\n    properties: {};\n    children: Template[];\n    [V_SYM]: true;\n};\n\n/**\n * The interface of a functional component.\n */\nexport type VFunction<T extends FunctionComponent> = {\n    type: T;\n    key: unknown;\n    namespace: string;\n    properties: VProperties<T>;\n    children: Template[];\n    [V_SYM]: true;\n};\n\n/**\n * The interface of an HTML node used as JSX tag.\n */\nexport type VElement<T extends Element> = {\n    type: T;\n    key: unknown;\n    namespace: string;\n    properties: VProperties<T>;\n    children: Template[];\n    [V_SYM]: true;\n};\n\n/**\n * The interface of a Component constructor used as JSX tag.\n */\nexport type VComponent<T extends CustomElementConstructor> = {\n    type: T;\n    key?: unknown;\n    namespace?: string;\n    properties: VProperties<InstanceType<T>>;\n    children: Template[];\n    [V_SYM]: true;\n};\n\n/**\n * The interface of slot element.\n */\nexport type VSlot = {\n    type: 'slot';\n    key: unknown;\n    properties: VProperties<'slot'>;\n    children: Template[];\n    [V_SYM]: true;\n};\n\n/**\n * The interface of a generic JSX tag.\n */\nexport type VTag<T extends string> = {\n    type: T;\n    key: unknown;\n    namespace: string;\n    properties: VProperties<T>;\n    children: Template[];\n    [V_SYM]: true;\n};\n\n/**\n * Generic virtual dom object.\n */\nexport type VObject = VFunction<FunctionComponent>\n    | VComponent<CustomElementConstructor>\n    | VElement<Element>\n    | VSlot\n    | VTag<string>\n    | VFragment;\n\n/**\n * A generic template. Can be a single atomic item or a list of items.\n */\nexport type Template =\n    Element\n    | Text\n    | Node\n    | VFragment\n    | VFunction<FunctionComponent>\n    | VComponent<CustomElementConstructor>\n    | VElement<Element>\n    | VSlot\n    | VTag<string>\n    | Promise<unknown>\n    | Observable<unknown>\n    | string\n    | number\n    | boolean\n    | undefined\n    | null\n    | Template[];\n\n/**\n * Check if the current virtual node is a fragment.\n * @param target The node to check.\n * @returns True if the target is a virtual DOM object.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isVObject = (target: any): target is VObject => !!target[V_SYM];\n\n/**\n * Check if the current virtual node is a fragment.\n * @param target The node to check.\n * @returns True if the target is a fragment.\n */\nexport const isVFragment = (target: VObject): target is VFragment => target.type === Fragment;\n\n/**\n * Check if the current virtual node is a functional component.\n * @param target The node to check.\n * @returns True if the target is a functional component.\n */\nexport const isVFunction = (target: VObject): target is VFunction<FunctionComponent> => typeof target.type === 'function' && !isCustomElementConstructor(target.type);\n\n/**\n * Check if the current virtual node is a Component.\n * @param target The node to check.\n * @returns True if the target is a Component node.\n */\nexport const isVComponent = (target: VObject): target is VComponent<CustomElementConstructor> => typeof target.type === 'function' && isCustomElementConstructor(target.type);\n\n/**\n * Check if the current virtual node is an HTML node instance.\n * @param target The node to check.\n * @returns True if the target is an HTML node instance.\n */\nexport const isVNode = (target: VObject): target is VElement<Element> => isNode(target.type);\n\n/**\n * Check if the current virtual node is a slot element.\n * @param target The node to check.\n * @returns True if the target is a slot element.\n */\nexport const isVSlot = (target: VObject): target is VSlot => target.type === 'slot';\n\n/**\n * Check if the current virtual node is a generic tag to render.\n * @param target The node to check.\n * @returns True if the target is a generic tag to render.\n */\nexport const isVTag = (target: VObject): target is VTag<string> => typeof target.type === 'string';\n\nfunction h(tagOrComponent: typeof Fragment): VFragment;\nfunction h(tagOrComponent: typeof Fragment, properties: null, ...children: Template[]): VFragment;\nfunction h<T extends FunctionComponent>(tagOrComponent: T, properties?: VProperties<T> | null, ...children: Template[]): VFunction<T>;\nfunction h<T extends CustomElementConstructor>(tagOrComponent: T, properties?: VProperties<InstanceType<T>> | null, ...children: Template[]): VComponent<T>;\n/**\n * @deprecated Use the `ref` property instead.\n */\nfunction h<T extends Element>(tagOrComponent: T, properties?: VProperties<T> | null, ...children: Template[]): VElement<T>;\nfunction h(tagOrComponent: 'slot', properties?: VProperties<'slot'> | null, ...children: Template[]): VSlot;\nfunction h<T extends string>(tagOrComponent: T, properties?: VProperties<T> | null, ...children: Template[]): VTag<T>;\n/**\n * Function factory to use as JSX pragma.\n *\n * @param tagOrComponent The tag name, the constructor or the instance of the node.\n * @param properties The set of properties of the Node.\n * @param children The children of the Node.\n * @returns The virtual DOM object.\n */\nfunction h(\n    tagOrComponent: typeof Fragment | FunctionComponent | CustomElementConstructor | Element | string,\n    properties: VProperties | null = null,\n    ...children: Template[]\n) {\n    const { children: propertiesChildren } = (properties || {});\n    children = propertiesChildren as Template[] || children;\n\n    const normalizedProperties: { [key: string]: unknown } = {};\n\n    let key: unknown;\n    let is: string|undefined;\n    let xmlns: string|undefined;\n    let ref: Element|undefined;\n    for (const k in properties) {\n        if (k === 'is') {\n            is = properties.is;\n        } else if (k === 'xmlns') {\n            xmlns = properties.xmlns;\n        } else if (k === 'ref') {\n            ref = properties.ref;\n        } else if (k === 'key') {\n            key = properties.key;\n        } else if (k === 'children') {\n            // ensure children is array (jsx automatic runtime flats children)\n            children = isArray(properties.children) ? properties.children : [properties.children] as Template[];\n        } else {\n            normalizedProperties[k] = properties[k];\n        }\n    }\n\n    if (is) {\n        tagOrComponent = customElements.get(is) || tagOrComponent;\n    } else if (typeof tagOrComponent === 'string') {\n        tagOrComponent = customElements.get(tagOrComponent) || tagOrComponent;\n    }\n\n    const vnode = {\n        type: ref || tagOrComponent,\n        key,\n        children,\n        properties: normalizedProperties,\n        namespace: (tagOrComponent as unknown as string) === 'svg' ? 'http://www.w3.org/2000/svg' : xmlns,\n        [V_SYM]: true,\n    } as (typeof tagOrComponent extends typeof Fragment ? VFragment : VObject);\n\n    return vnode;\n}\n\n/**\n * Function factory to use as JSX pragma.\n *\n * @param tagOrComponent The tag name, the constructor or the instance of the node.\n * @param properties The set of properties of the Node.\n * @param key The Node key reference.\n * @returns The virtual DOM object.\n */\nfunction jsx(\n    tagOrComponent: typeof Fragment | FunctionComponent | CustomElementConstructor | Element | string,\n    properties: VProperties | null = null,\n    key?: unknown\n) {\n    properties = properties || {};\n    if (key) {\n        properties.key = key;\n    }\n    return h(tagOrComponent as string, properties as VProperties<string>);\n}\n\nconst jsxs = jsx;\n\nexport { h, jsx, jsxs };\n\n/**\n * The internal JSX namespace.\n */\nexport namespace JSXInternal {\n    export interface CustomElements { }\n\n    export type Element = Template;\n\n    export type IntrinsicElements = {\n        [K in keyof CustomElements]:\n            'extends' extends keyof JSXInternal.CustomElements[K] ?\n                never :\n                VProperties<CustomElements[K]>;\n    } & {\n        [K in keyof HTMLTagNameMap]: VProperties<K>;\n    } & {\n        [K in keyof SVGTagNameMap]: VProperties<SVGTagNameMap[K]>\n    };\n}\n\n/**\n * Configure JSX support.\n */\ndeclare global {\n    namespace JSX {\n        type Element = JSXInternal.Element;\n        type IntrinsicElements = JSXInternal.IntrinsicElements;\n    }\n\n    interface HTMLElementTagNameMap extends JSXInternal.CustomElements { }\n}\n", "/**\n * A Symbol which contains Thenable state.\n */\nconst THENABLE_SYMBOL: unique symbol = Symbol();\n\ntype WithThenableState<T> = T & {\n    [THENABLE_SYMBOL]?: ThenableState;\n};\n\n/**\n * An object representing the status of a Thenable.\n */\nexport type ThenableState = {\n    pending: boolean;\n    result?: unknown;\n};\n\n/**\n * Check if the target is a Thenable (has the `then` method).\n * @param target The object to check.\n * @returns True if the target is a Thenable.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isThenable = (target: any): target is Promise<any> => typeof target.then === 'function';\n\n/**\n * Get or inject a state into a Thenable object.\n * @param target The Thenable to extend.\n * @returns The Thenable state instance.\n */\nexport const getThenableState = (target: WithThenableState<Promise<unknown>>): ThenableState => {\n    const state = target[THENABLE_SYMBOL];\n    if (state) {\n        return state;\n    }\n\n    const newState = target[THENABLE_SYMBOL] = {\n        pending: true,\n    } as ThenableState;\n    target\n        .then((result: unknown) => {\n            newState.result = result;\n            newState.pending = false;\n        })\n        .catch((error: unknown) => {\n            newState.result = error;\n            newState.pending = false;\n        });\n\n    return newState;\n};\n", "/**\n * Subscription-like minimal interface.\n */\nexport type Subscription = {\n    unsubscribe(): void;\n};\n\n/**\n * Observable-like minimal interface.\n */\nexport type Observable<T> = {\n    pipe(operator: (value: T) => unknown): Observable<T>;\n    subscribe(nextCallback: (value: T) => unknown, errorCallback: (error: Error) => unknown, completeCallback: () => unknown): Subscription;\n};\n\n/**\n * A Symbol which contains Subscription state.\n */\nconst SUBSCRIPTION_SYMBOL: unique symbol = Symbol();\n\ntype WithObservableState<T> = T & {\n    [SUBSCRIPTION_SYMBOL]?: ObservableState;\n};\n\n/**\n * An object representing the status of a Subscribable.\n */\nexport type ObservableState = {\n    complete: boolean;\n    errored: boolean;\n    current?: unknown;\n};\n\n/**\n * Check if the target is a Subscribable (has the `subscribe` method).\n * @param target The object to check.\n * @returns True if the target is a Subscribable.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isObservable = (target: any): target is Observable<unknown> => typeof target['subscribe'] === 'function';\n\n/**\n * Get or inject a state into a Subscribable object.\n * @param target The Subscribable to extend.\n * @returns The Subscribable state instance.\n */\nexport const getObservableState = <T extends Observable<unknown>>(target: WithObservableState<T>): ObservableState => {\n    const state = target[SUBSCRIPTION_SYMBOL];\n    if (state) {\n        return state;\n    }\n    const newState = target[SUBSCRIPTION_SYMBOL] = {\n        complete: false,\n        errored: false,\n    } as ObservableState;\n    target\n        .subscribe((value) => {\n            newState.current = value;\n            newState.errored = false;\n        }, (error) => {\n            newState.current = error;\n            newState.errored = true;\n        }, () => {\n            newState.complete = true;\n        });\n\n    return newState;\n};\n", "/**\n * A cache for scoped CSS.\n */\nconst CACHE: {\n    [key: string]: {\n        [key: string]: string;\n    };\n} = {};\n\n/**\n * Match all `:host` selectors in a CSS string.\n */\nconst HOST_REGEX = /:host(\\(([^({)]+(\\([^)]*\\))?)+\\))?/g;\n\n/**\n * Match all comments in a CSS string.\n */\nconst CSS_COMMENTS_REGEX = /\\s*\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\/\\s*/g;\n\n/**\n * Match all css selectors in a CSS string.\n */\nconst CSS_SELECTORS_REGEX = /(#|\\*|\\.|@|\\[|[a-zA-Z])([^{;}]*){/g;\n\n/**\n * Scope a CSS string, adding a compnent-specific trailing selector to all rules.\n * It also converts `:host` selectors for cross browser compatibility.\n * @param name The component definition name.\n * @param cssText The CSS string.\n * @param extend The builtin element.\n * @returns A scoped CSS string.\n * @throws If the scope name is not a string.\n * @throws If the CSS value is not a string.\n */\nexport const css = (name: string, cssText: string, extend?: string): string => {\n    if (typeof name !== 'string') {\n        throw new TypeError('The provided name must be a string');\n    }\n    if (typeof cssText !== 'string') {\n        throw new TypeError('The provided CSS text must be a string');\n    }\n\n    const cached = CACHE[name] = CACHE[name] || {};\n    const scope = extend && extend !== name ? `${extend}[is=\"${name}\"]` : name;\n    if (cssText in cached) {\n        return cached[cssText];\n    }\n    return cached[cssText] = cssText\n        .replace(CSS_COMMENTS_REGEX, '\\n')\n        .replace(HOST_REGEX, (fullMatch, mod) => `${scope}${mod ? mod.slice(1, -1).replace(':defined', '[:defined]') : ''}`)\n        .replace(CSS_SELECTORS_REGEX, (match) => {\n            match = match.trim();\n            if (match[0] === '@') {\n                return match;\n            }\n            return match\n                .split(',')\n                .map((selector) => {\n                    selector = selector.trim();\n                    if (selector.indexOf(scope) === 0) {\n                        return selector;\n                    }\n                    return `${scope} ${selector}`;\n                })\n                .join(',');\n        });\n};\n", "import type { VClasses, VStyle, Template } from './JSX';\nimport type { ComponentInstance } from './Component';\nimport type { Store, UpdateRequest } from './FunctionComponent';\nimport type { Context } from './Context';\nimport htm from 'htm';\nimport { isNode, isElement, isText, isArray, getPropertyDescriptor } from './helpers';\nimport { h, isVFragment, isVObject, isVTag, isVComponent, isVSlot, isVFunction, isVNode } from './JSX';\nimport { customElements } from './CustomElementRegistry';\nimport { isComponent } from './Component';\nimport { DOM } from './DOM';\nimport { isThenable, getThenableState } from './Thenable';\nimport { isObservable, getObservableState } from './Observable';\nimport { css } from './css';\nimport { getProperty } from './property';\nimport { getHostContext, getContext, getOrCreateContext } from './Context';\n\nconst innerHtml = htm.bind(h);\n\n/**\n * Compile a string into virtual DOM template.\n * @param string The string to compile.\n * @returns The virtual DOM template.\n */\nexport const compile = (string: string): Template => {\n    const array = [string] as string[] & { raw?: string[] };\n    array.raw = [string];\n    return innerHtml(array as unknown as TemplateStringsArray);\n};\n\nfunction html(string: TemplateStringsArray, ...values: unknown[]): Template;\n/**\n * @deprecated use `compile` function instead.\n */\nfunction html(string: string): Template;\n/**\n * Compile a template string into virtual DOM template.\n * @param string The string to compile.\n * @param values Values to interpolate.\n * @returns The virtual DOM template.\n */\nfunction html(string: string | TemplateStringsArray, ...values: unknown[]): Template {\n    if (typeof string === 'string') {\n        return compile(string);\n    }\n    return innerHtml(string, ...values);\n}\n\nexport { html };\n\n/**\n* A filter function signature for template items.\n*\n* @param item The template item to check.\n* @returns A truthy value for valid items, a falsy for value for invalid ones.\n*/\nexport type Filter = (item: Node) => boolean;\n\n/**\n * Convert strings or classes map to a list of classes.\n * @param value The value to convert.\n * @returns A list of classes.\n */\nconst convertClasses = (value: VClasses | null | undefined) => {\n    const classes: string[] = [];\n    if (!value) {\n        return classes;\n    }\n    if (typeof value === 'object') {\n        for (const k in value) {\n            if (value[k]) {\n                classes.push(k);\n            }\n        }\n        return classes;\n    }\n    return value.toString().trim().split(' ');\n};\n\n/**\n * Convert strings or styles map to a list of styles.\n * @param value The value to convert.\n * @returns A set of styles.\n */\nconst convertStyles = (value: VStyle| null | undefined) => {\n    const styles: { [key: string]: string } = {};\n    if (!value) {\n        return styles;\n    }\n    if (typeof value === 'object') {\n        for (const propertyKey in value) {\n            const camelName = propertyKey.replace(/[A-Z]/g, (match: string) =>\n                `-${match.toLowerCase()}`\n            );\n            const propValue = value[propertyKey];\n            if (propValue != null) {\n                styles[camelName] = propValue;\n            }\n        }\n        return styles;\n    }\n    return value\n        .toString()\n        .split(';')\n        .reduce((ruleMap: { [key: string]: string }, ruleString: string) => {\n            const rulePair = ruleString.split(':');\n            if (rulePair.length > 1) {\n                ruleMap[(rulePair.shift() as string).trim()] = rulePair.join(':').trim();\n            }\n            return ruleMap;\n        }, styles);\n};\n\n/**\n * Check if the render engine is handling input values.\n * @param element The current node element.\n * @param propertyKey The changed property key.\n * @returns True if the render engine is handling input elements, false otherwise.\n */\nconst isRenderingInput = (element: Node, propertyKey: string): element is HTMLInputElement =>\n    (propertyKey === 'checked' || propertyKey === 'value') &&\n    (element as HTMLElement).tagName === 'INPUT';\n\n/**\n * Set a value to an HTML element.\n * @param element The node to update.\n * @param propertyKey The key to update.\n * @param value The value to set.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst setValue = <T extends Node>(element: T, propertyKey: PropertyKey, value: any) => {\n    element[propertyKey as keyof T] = value;\n};\n\n/**\n * Check if a property key is a listener key and it should be valued as event listener.\n * @param propertyKey The property to check.\n * @returns True if the property is a listener, false otherwise.\n */\nconst isListenerProperty = (propertyKey: string): propertyKey is `on${string}` => propertyKey[0] === 'o' && propertyKey[1] === 'n';\n\n/**\n * Get the current iterating node in rendering context.\n * @param context The rendering context.\n * @returns A node instance or null.\n */\nconst getCurrentNode = (context: Context) => (context.children[context.currentIndex as number] || null);\n\n/**\n * Get the current iterating context in rendering context.\n * @param context The rendering context.\n * @returns A context or null.\n */\nconst getCurrentContext = (context: Context) => {\n    const currentNode = getCurrentNode(context);\n    if (!currentNode) {\n        return null;\n    }\n    return getHostContext(currentNode) || getContext(currentNode) || null;\n};\n\n/**\n * Get a keyed node in the rendering context.\n * @param context The rendering context.\n * @param key The key to find.\n * @returns A node instance or null.\n */\nconst getKeyedNode = (context: Context, key: unknown) => {\n    context = context.fragment || context;\n    return context.oldKeys && context.oldKeys.get(key) || null;\n};\n\n/**\n * Check if a node instance is keyed in the rendering context.\n * @param context The rendering context.\n * @param node The node to check.\n * @returns True if keyed, false otherwise.\n */\nconst hasKeyedNode = (context: Context, node: Node) => {\n    context = context.fragment || context;\n    return context.oldKeyed ? context.oldKeyed.has(node) : null;\n};\n\n/**\n * Add keyed node to rendering context.\n * @param context The rendering context.\n * @param node The node to add.\n * @param key The key to add.\n */\nconst addKeyedNode = (context: Context, node: Node, key: unknown) => {\n    context = context.fragment || context;\n    context.keys = context.keys || new Map();\n    context.keys.set(key, node);\n};\n\n/**\n * Render a a template into the root.\n * @param parent The root Node for the render.\n * @param slot Should handle slot children.\n * @param context The render context of the root.\n * @param root The render root.\n * @param rootContext The render root context.\n * @param template The template to render in Virtual DOM format.\n * @param filter The filter function for slotted nodes.\n * @returns The count of rendered children.\n */\nconst renderTemplate = (\n    parent: Node,\n    slot: boolean,\n    context: Context,\n    root: Node,\n    rootContext: Context,\n    template: Template,\n    filter?: Filter\n): number => {\n    if (template == null || template === false) {\n        return 0;\n    }\n\n    const isObject = typeof template === 'object';\n    if (isObject && isArray(template)) {\n        let childCount = 0;\n        // call the render function for each child\n        for (let i = 0, len = template.length; i < len; i++) {\n            childCount += renderTemplate(\n                parent,\n                slot,\n                context,\n                root,\n                rootContext,\n                template[i],\n                filter\n            );\n        }\n        return childCount;\n    }\n\n    let templateNode: Node | undefined;\n    let templateContext: Context | undefined;\n    let templateChildren: Template[] | undefined;\n    let templateNamespace = context.namespace as string;\n\n    if (isObject && isVObject(template)) {\n        if (isVFragment(template)) {\n            return renderTemplate(\n                parent,\n                slot,\n                context,\n                root,\n                rootContext,\n                template.children,\n                filter\n            );\n        }\n\n        if (isVFunction(template)) {\n            const { type: Function, key, properties, children } = template;\n            const rootFragment = context.fragment;\n\n            let placeholder: Node;\n            let renderContext: Context;\n            if (rootFragment) {\n                placeholder = rootFragment.start as Node;\n                renderContext = (getHostContext(placeholder) || getContext(placeholder)) as Context;\n            } else if (key && (placeholder = getKeyedNode(context, key) as Node)) {\n                renderContext = getOrCreateContext(placeholder);\n            } else if (key == null\n                && (renderContext = getCurrentContext(context) as Context)\n                && (placeholder = getCurrentNode(context))\n                && renderContext.Function === Function\n                && !hasKeyedNode(context, placeholder)\n            ) {\n                //\n            } else {\n                placeholder = DOM.createComment(Function.name);\n                renderContext = getOrCreateContext(placeholder);\n            }\n            if (key != null) {\n                addKeyedNode(context, placeholder, key);\n            }\n\n            const isAttached = () => context.children.indexOf(placeholder) !== -1;\n            let running = true;\n            const requestUpdate: UpdateRequest = renderContext.requestUpdate = () => {\n                if (renderContext.requestUpdate !== requestUpdate) {\n                    return (renderContext.requestUpdate as UpdateRequest)();\n                }\n                if (running) {\n                    throw new Error('An update request is already running');\n                }\n                if (!isAttached()) {\n                    return false;\n                }\n                internalRender(\n                    parent,\n                    template,\n                    slot,\n                    context,\n                    root,\n                    rootContext,\n                    context.namespace,\n                    renderContext\n                );\n                return true;\n            };\n            renderContext.Function = Function;\n            renderContext.start = placeholder;\n            renderContext.store = renderContext.store || new Map();\n            context.fragment = undefined;\n\n            const childCount = renderTemplate(\n                parent,\n                slot,\n                context,\n                root,\n                rootContext,\n                [\n                    placeholder,\n                    Function(\n                        {\n                            children,\n                            ...properties,\n                        },\n                        renderContext as Context & {\n                            store: Store;\n                            requestUpdate: UpdateRequest;\n                        },\n                        requestUpdate,\n                        isAttached,\n                        renderContext\n                    ),\n                ],\n                filter\n            );\n\n            context.fragment = rootFragment;\n            renderContext.end = context.children[context.currentIndex as number - 1];\n\n            running = false;\n            return childCount;\n        }\n\n        // if the current patch is a slot,\n        if (isVSlot(template)) {\n            const hostContext = getHostContext(root);\n            if (!hostContext) {\n                return 0;\n            }\n            const slotted = hostContext.children;\n            const { properties, children } = template;\n            const name = properties.name;\n            const filter = (item: Node) => {\n                const slotContext = getContext(item);\n                if (!slotContext || !slotContext.hosts || slotContext.hosts[0] === root) {\n                    if (isElement(item)) {\n                        if (!name) {\n                            return !item.getAttribute('slot');\n                        }\n\n                        return item.getAttribute('slot') === name;\n                    }\n                }\n\n                return !name;\n            };\n\n            const childCount = renderTemplate(\n                parent,\n                slot,\n                context,\n                root,\n                rootContext,\n                slotted,\n                filter\n            );\n            if (!childCount) {\n                return renderTemplate(\n                    parent,\n                    slot,\n                    context,\n                    root,\n                    rootContext,\n                    children\n                );\n            }\n            return childCount;\n        }\n\n        const { key, children, namespace: namespaceURI } = template;\n        templateNamespace = namespaceURI || context.namespace as string;\n\n        let currentNode: Node | null;\n        let currentContext: Context | null;\n        let isNew = false;\n        if (key != null) {\n            templateNode = getKeyedNode(context, key) as Node;\n        } else if ((currentNode = getCurrentNode(context))\n            && (currentContext = getCurrentContext(context))\n            && isElement(currentNode)\n            && !hasKeyedNode(context, currentNode)\n            && (!currentContext.parents || currentContext.parents[0] === rootContext)\n        ) {\n            if (isVComponent(template) && currentNode.constructor === template.type) {\n                templateNode = currentNode;\n                templateContext = currentContext;\n            } else if (isVTag(template) && currentNode.tagName.toLowerCase() === template.type.toLowerCase()) {\n                templateNode = currentNode;\n                templateContext = currentContext;\n            }\n        }\n\n        if (!templateNode) {\n            if (isVNode(template)) {\n                templateNode = template.type;\n            } else if (isVComponent(template)) {\n                templateNode = new template.type();\n                isNew = true;\n            } else {\n                templateNode = DOM.createElementNS(templateNamespace, template.type);\n                isNew = true;\n            }\n        }\n\n        if (key != null) {\n            addKeyedNode(context, templateNode, key);\n        }\n\n        // update the Node properties\n        templateContext = templateContext || getHostContext(templateNode) || getOrCreateContext(templateNode);\n        if (isNew) {\n            templateContext.parents = [rootContext];\n        }\n        const oldProperties = templateContext.properties.get(rootContext);\n        const properties = template.properties;\n        if (oldProperties) {\n            for (const key in oldProperties) {\n                if (!(key in properties)) {\n                    properties[key as keyof typeof properties] = undefined;\n                }\n            }\n        }\n        templateContext.properties.set(rootContext, properties);\n\n        let propertyKey: keyof typeof properties;\n        for (propertyKey in properties) {\n            const value = properties[propertyKey];\n            const oldValue = oldProperties && oldProperties[propertyKey];\n            if (oldValue === value) {\n                if (isRenderingInput(templateNode, propertyKey)) {\n                    setValue(templateNode, propertyKey as unknown as 'value', value);\n                }\n                continue;\n            }\n\n            if (propertyKey === 'style') {\n                const style = (templateNode as HTMLElement).style;\n                const oldStyles = convertStyles(oldValue as VStyle);\n                const newStyles = convertStyles(value as VStyle);\n                for (const propertyKey in oldStyles) {\n                    if (!(propertyKey in newStyles)) {\n                        style.removeProperty(propertyKey);\n                    }\n                }\n                for (const propertyKey in newStyles) {\n                    style.setProperty(propertyKey, newStyles[propertyKey]);\n                }\n                continue;\n            } else if (propertyKey === 'class') {\n                const classList = (templateNode as HTMLElement).classList;\n                const newClasses = convertClasses(value as VClasses);\n                if (oldValue) {\n                    const oldClasses = convertClasses(oldValue as VClasses);\n                    for (let i = 0, len = oldClasses.length; i < len; i++) {\n                        const className = oldClasses[i];\n                        if (newClasses.indexOf(className) === -1) {\n                            classList.remove(className);\n                        }\n                    }\n                }\n                for (let i = 0, len = newClasses.length; i < len; i++) {\n                    const className = newClasses[i];\n                    if (!classList.contains(className)) {\n                        classList.add(className);\n                    }\n                }\n                continue;\n            } else if (isListenerProperty(propertyKey) && !(propertyKey in templateNode.constructor.prototype)) {\n                const eventName = propertyKey.substr(2);\n                if (oldValue) {\n                    (templateNode as HTMLElement).removeEventListener(eventName, oldValue as EventListener);\n                }\n                if (value) {\n                    (templateNode as HTMLElement).addEventListener(eventName, value as EventListener);\n                }\n                continue;\n            }\n\n            const type = typeof value;\n            const wasType = typeof oldValue;\n            const isReference = (value && type === 'object') || type === 'function';\n            const wasReference = (oldValue && wasType === 'object') || wasType === 'function';\n\n            if (isReference || wasReference || isRenderingInput(templateNode, propertyKey)) {\n                setValue(templateNode, propertyKey, value);\n            } else if (isVComponent(template)) {\n                if (type === 'string') {\n                    const observedAttributes = template.type.observedAttributes;\n                    if (!observedAttributes || observedAttributes.indexOf(propertyKey) === -1) {\n                        const descriptor = (propertyKey in templateNode) && getPropertyDescriptor(templateNode, propertyKey);\n                        if (!descriptor || !descriptor.get || descriptor.set) {\n                            setValue(templateNode, propertyKey, value);\n                        }\n                    } else {\n                        const property = getProperty(templateNode as ComponentInstance, propertyKey as keyof ComponentInstance);\n                        if (property && property.fromAttribute) {\n                            setValue(templateNode, propertyKey, (property.fromAttribute as Function).call(templateNode, value as string));\n                        }\n                    }\n                } else {\n                    setValue(templateNode, propertyKey, value);\n                }\n            }\n\n            if (value == null || value === false) {\n                if ((templateNode as HTMLElement).hasAttribute(propertyKey)) {\n                    (templateNode as HTMLElement).removeAttribute(propertyKey);\n                }\n            } else if (!isReference) {\n                const attrValue = value === true ? '' : (value as string).toString();\n                if ((templateNode as HTMLElement).getAttribute(propertyKey) !== attrValue) {\n                    (templateNode as HTMLElement).setAttribute(propertyKey, attrValue);\n                }\n            }\n        }\n\n        templateChildren = children;\n    } else if (isObject && isThenable(template)) {\n        return renderTemplate(\n            parent,\n            slot,\n            context,\n            root,\n            rootContext,\n            h((props, context) => {\n                const status = getThenableState(template as Promise<unknown>);\n                if (status.pending) {\n                    (template as Promise<unknown>)\n                        .catch(() => 1)\n                        .then(() => {\n                            context.requestUpdate();\n                        });\n                }\n                return status.result as Template;\n            }, null),\n            filter\n        );\n    } else if (isObject && isObservable(template)) {\n        const observable = template;\n        return renderTemplate(\n            parent,\n            slot,\n            context,\n            root,\n            rootContext,\n            h((props, context) => {\n                const status = getObservableState(observable);\n                if (!status.complete) {\n                    const subscription = observable.subscribe(\n                        () => {\n                            if (!context.requestUpdate()) {\n                                subscription.unsubscribe();\n                            }\n                        },\n                        () => {\n                            if (!context.requestUpdate()) {\n                                subscription.unsubscribe();\n                            }\n                        },\n                        () => {\n                            subscription.unsubscribe();\n                        }\n                    );\n                }\n                return status.current as Template;\n            }, null),\n            filter\n        );\n    } else if (isObject && isNode(template)) {\n        templateNode = template;\n        templateContext = templateContext || getHostContext(templateNode) || getOrCreateContext(templateNode);\n    } else {\n        const hostContext = getHostContext(root);\n        if (typeof template === 'string' && hostContext && hostContext.host && (parent as HTMLElement).tagName === 'STYLE') {\n            template = css(hostContext.host, template as string, customElements.tagNames[hostContext.host]);\n            (parent as HTMLStyleElement).setAttribute('name', hostContext.host);\n        }\n\n        let currentNode: Node;\n        let currentContext: Context | null;\n        if ((currentNode = getCurrentNode(context))\n            && (currentContext = getCurrentContext(context))\n            && isText(currentNode)\n            && (!currentContext.parents || currentContext.parents[0] === rootContext)\n        ) {\n            templateNode = currentNode;\n            templateContext = currentContext;\n            if (templateNode.textContent != template) {\n                templateNode.textContent = template as string;\n            }\n        } else {\n            // convert non-Node template into Text\n            templateNode = DOM.createTextNode(template as string);\n            templateContext = getOrCreateContext(templateNode);\n            templateContext.parents = [rootContext];\n        }\n    }\n\n    if (!templateNode || !templateContext || (filter && !filter(templateNode))) {\n        return 0;\n    }\n\n    // now, we are confident that the input is a Node,\n    if (context.children.indexOf(templateNode) !== -1) {\n        // the node is already in the child list\n        // remove nodes until the correct instance\n        let currentContext: Context | null;\n        while ((currentContext = getCurrentContext(context)) && (templateContext !== currentContext)) {\n            DOM.removeChild(parent, getCurrentNode(context), slot, false);\n        }\n\n        (context.currentIndex as number)++;\n    } else {\n        // we need to insert the new node into the tree\n        DOM.insertBefore(parent, templateNode, getCurrentNode(context), slot, false);\n        (context.currentIndex as number)++;\n    }\n\n    if (templateNode &&\n        templateContext &&\n        isElement(templateNode) &&\n        ((templateChildren && templateChildren.length) || ((!templateContext.parents || (templateContext.parents[0] === rootContext)) && templateContext.children.length))) {\n        // the Node has slotted children, trigger a new render context for them\n        if (!templateContext.parents) {\n            templateContext.parents = [rootContext];\n        }\n        internalRender(\n            templateNode,\n            templateChildren,\n            isComponent(templateNode),\n            templateContext,\n            root,\n            rootContext,\n            templateNamespace\n        );\n    }\n\n    return 1;\n};\n\n/**\n * Render a set of nodes into the render root, with some checks for Nodes in order to avoid\n * useless changes in the tree and to mantain or update the state of compatible Nodes.\n *\n * @param parent The root Node for the render.\n * @param template The child (or the children) to render in Virtual DOM format or already generated.\n * @param slot Should handle slot children.\n * @param context The render context of the root.\n * @param root The current root node of the render.\n * @param rootContext The current root context of the render.\n * @param namespace The current namespace uri of the render.\n * @param fragment The fragment context to update.\n * @returns The resulting child nodes list.\n */\nexport const internalRender = (\n    parent: Node,\n    template: Template,\n    slot = isComponent(parent),\n    context: Context,\n    root: Node,\n    rootContext: Context = context,\n    namespace: string = (parent as HTMLElement).namespaceURI || 'http://www.w3.org/1999/xhtml',\n    fragment?: Context\n) => {\n    const childNodes = context.children;\n    const previousFragment = context.fragment;\n    const previousNamespace = context.namespace;\n    const previousIndex = context.currentIndex;\n\n    if (!context.parents) {\n        context.parents = [context];\n    }\n    context.namespace = namespace;\n    context.fragment = fragment;\n\n    let lastNode: Node | undefined;\n    if (fragment) {\n        context.currentIndex = context.children.indexOf(fragment.start as Node);\n        lastNode = fragment.end as Node;\n        if (fragment.keys) {\n            fragment.oldKeys = fragment.keys;\n            fragment.oldKeyed = new Set(fragment.keys.values());\n        }\n        delete fragment.keys;\n    } else {\n        context.currentIndex = 0;\n        if (context.keys) {\n            context.oldKeys = context.keys;\n            context.oldKeyed = new Set(context.keys.values());\n        }\n        delete context.keys;\n    }\n\n    renderTemplate(\n        parent,\n        slot,\n        context,\n        root,\n        rootContext,\n        template\n    );\n\n    // all children of the root have been handled,\n    // we can start to cleanup the tree\n    // remove all Nodes that are outside the result range\n    const currentIndex = context.currentIndex as number;\n    let lastIndex: number;\n    if (lastNode) {\n        lastIndex = childNodes.indexOf(lastNode) + 1;\n    } else {\n        lastIndex = childNodes.length;\n    }\n    while (currentIndex < lastIndex) {\n        DOM.removeChild(parent, childNodes[--lastIndex], slot, false);\n    }\n\n    if (fragment) {\n        delete fragment.oldKeys;\n        delete fragment.oldKeyed;\n        context.fragment = previousFragment;\n        context.namespace = previousNamespace;\n    } else {\n        delete context.oldKeys;\n        delete context.oldKeyed;\n        context.fragment = previousFragment;\n        context.namespace = previousNamespace;\n        context.currentIndex = previousIndex;\n    }\n\n    if (slot) {\n        (parent as ComponentInstance).forceUpdate();\n    }\n\n    return childNodes;\n};\n\n/**\n * Render a set of Nodes into another, with some checks for Nodes in order to avoid\n * useless changes in the tree and to mantain or update the state of compatible Nodes.\n *\n * @param input The child (or the children) to render in Virtual DOM format or already generated.\n * @param root The root Node for the render.\n * @param slot Should render to slot children.\n * @returns The resulting child Nodes.\n */\nexport const render = (input: Template, root: Node = DOM.createDocumentFragment(), slot: boolean = true): Node | Node[] | void => {\n    const isComponentRoot = isComponent(root);\n    const childNodes = internalRender(\n        root,\n        input,\n        slot && isComponentRoot,\n        slot && isComponentRoot ? getHostContext(root) as Context : getOrCreateContext(root),\n        root\n    );\n    if (!isArray(input) && !(input != null && isVObject(input) && isVFragment(input)) && childNodes.length < 2) {\n        return childNodes[0];\n    }\n    return childNodes.slice(0);\n};\n", "import type { Template } from './JSX';\nimport type { FunctionComponent } from './FunctionComponent';\nimport { cloneChildNodes } from './helpers';\nimport { DOM } from './DOM';\nimport { h } from './JSX';\nimport { customElements } from './CustomElementRegistry';\nimport { getThenableState } from './Thenable';\n\n/**\n * A dom parser function component.\n * @param props The props of the parser.\n * @param context The render context.\n * @returns A list of nodes to render.\n */\nconst DOMParse: FunctionComponent<{ source: string }> = (props, context) => {\n    const source = props.source;\n    const store = context.store;\n\n    if (store.get('source') === source) {\n        return store.get('dom') as Node[];\n    }\n\n    const wrapper = DOM.createElement('div');\n    wrapper.innerHTML = source;\n    customElements.upgrade(wrapper);\n    const dom = cloneChildNodes(wrapper.childNodes);\n    store.set('source', source);\n    store.set('dom', dom);\n    return dom;\n};\n\n/**\n * Convert an HTML string to DOM nodes.\n * @param string The HTML string to conver.\n * @returns The virtual DOM template function.\n */\nexport const parseDOM = (string: string): Template => h(DOMParse, { source: string });\n\n/**\n * It renders the template when then provided Thenable is in pending status.\n * @param thenable The Promise-like object.\n * @param template The template to render.\n * @returns A promise which resolves the template while the Thenable is in pending status.\n */\nexport const until = (thenable: Promise<unknown>, template: Template) => {\n    const original = getThenableState(thenable);\n    const wrapper = thenable.then(() => false).catch(() => false);\n    const state = getThenableState(wrapper);\n    state.result = original.pending && template;\n    return wrapper;\n};\n", "import type { Constructor, ClassDescriptor } from './helpers';\nimport type { CustomElement, CustomElementConstructor } from './CustomElementRegistry';\nimport type { DelegatedEventCallback, ListenerConfig } from './events';\nimport type { PropertyConfig, PropertyObserver, PropertiesOf } from './property';\nimport type { Template } from './JSX';\nimport type { Context } from './Context';\nimport { addObserver, getProperty, reflectPropertyToAttribute, removeObserver, getProperties, reflectAttributeToProperty } from './property';\nimport { nativeCustomElements, HTMLElementConstructor, isConnected, hasAttributeImpl, setAttributeImpl, createElementImpl, setPrototypeOf, isElement, defineProperty, cloneChildNodes } from './helpers';\nimport { customElements } from './CustomElementRegistry';\nimport { DOM } from './DOM';\nimport { delegateEventListener, undelegateEventListener, dispatchEvent, dispatchAsyncEvent, getListeners, setListeners } from './events';\nimport { getHostContext, getOrCreateContext, getOrCreateHostContext } from './Context';\nimport { internalRender, render } from './render';\nimport { parseDOM } from './directives';\n\n/**\n * A symbol which identify components.\n */\nexport const COMPONENT_SYMBOL: unique symbol = Symbol();\n\n/**\n * A symbol which identify emulated components.\n */\nexport const EMULATE_LIFECYCLE_SYMBOL: unique symbol = Symbol();\n\n/**\n * An augmented node with component flags.\n */\nexport type WithComponentFlags<T> = T & {\n    [COMPONENT_SYMBOL]?: boolean;\n    [EMULATE_LIFECYCLE_SYMBOL]?: boolean;\n};\n\n/**\n * The component mixin interface.\n */\nexport interface ComponentMixin {\n    /**\n     * A set of watched properties.\n     */\n    readonly watchedProperties: PropertyKey[];\n\n    /**\n     * A flag with the connected value of the node.\n     */\n    get isConnected(): boolean;\n\n    /**\n     * A list of slot nodes.\n     */\n    get slotChildNodes(): Node[] | undefined;\n\n    /**\n     * Initialize component properties.\n     * @deprecated\n     */\n    initialize(): void;\n\n    /**\n     * Invoked each time one of a Component's state property is setted, removed, or changed.\n     *\n     * @param propertyName The name of the changed property.\n     * @param oldValue The previous value of the property.\n     * @param newValue The new value for the property (undefined if removed).\n     */\n    stateChangedCallback<P extends keyof Members<this>>(propertyName: P, oldValue: this[P] | undefined, newValue: this[P]): void;\n\n    /**\n     * Invoked each time one of a Component's property is setted, removed, or changed.\n     *\n     * @param propertyName The name of the changed property.\n     * @param oldValue The previous value of the property.\n     * @param newValue The new value for the property (undefined if removed).\n     */\n    propertyChangedCallback<P extends keyof Members<this>>(propertyName: P, oldValue: this[P] | undefined, newValue: this[P]): void;\n\n    /**\n     * Get the inner value of a property.\n     * This is an helper method for properties getters and setters.\n     * @param propertyName The name of the property to get.\n     * @returns The inner value of the property.\n     */\n    getInnerPropertyValue<P extends keyof Members<this>>(propertyName: P): this[P];\n\n    /**\n     * Set the inner value of a property.\n     * This is an helper method for properties getters and setters.\n     * @param propertyName The name of the property to get.\n     * @param value The inner value to set.\n     */\n    setInnerPropertyValue<P extends keyof Members<this>>(propertyName: P, value: this[P]): void;\n\n    /**\n     * Observe a Component Property.\n     *\n     * @param propertyName The name of the Property to observe\n     * @param observer The callback function\n     */\n    observe<P extends keyof Members<this>>(propertyName: P, observer: PropertyObserver<this[P]>): void;\n\n    /**\n     * Unobserve a Component Property.\n     *\n     * @param propertyName The name of the Property to unobserve\n     * @param observer The callback function to remove\n     */\n    unobserve<P extends keyof Members<this>>(propertyName: P, observer: PropertyObserver<this[P]>): void;\n\n    /**\n     * Dispatch a custom Event.\n     *\n     * @param event The event to dispatch or the name of the synthetic event to create.\n     * @param detail Detail object of the event.\n     * @param bubbles Should the event bubble.\n     * @param cancelable Should the event be cancelable.\n     * @param composed Is the event composed.\n     */\n    dispatchEvent(event: Event): boolean;\n    dispatchEvent(event: string, detail?: CustomEventInit['detail'], bubbles?: boolean, cancelable?: boolean, composed?: boolean): boolean;\n\n    /**\n     * Dispatch an async custom Event.\n     *\n     * @param event The event to dispatch or the name of the synthetic event to create.\n     * @param detail Detail object of the event.\n     * @param bubbles Should the event bubble.\n     * @param cancelable Should the event be cancelable.\n     * @param composed Is the event composed.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    dispatchAsyncEvent(event: Event): Promise<any[]>;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    dispatchAsyncEvent(event: string, detail?: CustomEventInit['detail'], bubbles?: boolean, cancelable?: boolean, composed?: boolean): Promise<any[]>;\n\n    /**\n     * Delegate an Event listener.\n     *\n     * @param eventName The event name to listen\n     * @param selector The selector to delegate\n     * @param callback The callback to trigger when an Event matches the delegation\n     */\n    delegateEventListener(event: string, selector: string | null, callback: DelegatedEventCallback, options ?: AddEventListenerOptions): void;\n\n    /**\n     * Remove an Event delegation.\n     *\n     * @param eventName The Event name to undelegate\n     * @param selector The selector to undelegate\n     * @param callback The callback to remove\n     */\n    undelegateEventListener(event: string, selector: string | null, callback: DelegatedEventCallback): void;\n\n    /**\n     * Render method of the Component.\n     *\n     * @returns The instances of the rendered Components and/or Nodes\n     */\n    render(): Template | undefined;\n\n    /**\n     * Force an element to re-render.\n     */\n    forceUpdate(): void;\n}\n\n/**\n * The basic DNA Component interface.\n * It's a Custom Element, but with some extra useful method.\n * @see [W3C specification]{@link https://w3c.github.io/webcomponents/spec/custom/}.\n */\nexport type ComponentInstance<T extends HTMLElement = HTMLElement> = CustomElement<T> & ComponentMixin;\n\n/**\n * Component prototype keys.\n */\nexport type PrototypeKeys = keyof CustomElement | keyof ComponentMixin;\n\n/**\n * Get all methods of a class, excluding inherited methods.\n */\nexport type MethodsOf<T> = Exclude<{\n    [K in keyof T]: T[K] extends Function ? K : never;\n}[keyof T], never & PrototypeKeys>;\n\n/**\n * Check if a property is flagged as readonly.\n */\nexport type IsReadonly<T, K extends keyof T> =\n    (<C>() => C extends { [Q in K]: T[K] } ? 1 : 2) extends (<C>() => C extends { -readonly [Q in K]: T[K] } ? 1 : 2) ? never : K;\n\n/**\n * Get all members of a class, excluding inherited members.\n */\nexport type Members<T> = {\n    [K in keyof T]?: K extends PrototypeKeys ? never : K extends IsReadonly<T, K> ? never : T[K];\n};\n\n/**\n * Get all members names of a class, excluding inherited members.\n */\nexport type MemberKeys<T> = Exclude<{\n    [K in keyof T]?: K extends PrototypeKeys ? never : K extends IsReadonly<T, K> ? never : K;\n}[keyof T], never | undefined>;\n\n/**\n * Get a filtered list of available members of a class, excluding inherited members.\n */\nexport type Props<T> = Partial<Pick<Members<T>, MemberKeys<T>>>;\n\n/**\n * The basic DNA Component constructor.\n */\nexport interface ComponentConstructor<T extends ComponentInstance = ComponentInstance> extends CustomElementConstructor<T> {\n    /**\n     * Define component properties.\n     */\n    readonly properties?: {\n        [key: string]: PropertyConfig;\n    };\n\n    /**\n     * Define component listeners.\n     */\n    readonly listeners?: {\n        [key: string]: ListenerConfig;\n    };\n\n    /**\n     * Identify shimmed constructors.\n     * Constructor will skip native constructing when true.\n     */\n    shim?: boolean;\n\n    /**\n     * Upgrade a plain element prototype.\n     * @param node The node to upgrade.\n     * @returns The new prototyped node.\n     */\n    upgrade(node: HTMLElement): T;\n\n    /**\n     * Create a new Component instance.\n     * @param node Instantiate the element using the given node instead of creating a new one.\n     * @param properties A set of initial properties for the element.\n     */\n    // We cannot infer component properties from the base class\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    new(node?: HTMLElement, properties?: { [key: string]: any }): T;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    new(properties?: { [key: string]: any }): T;\n\n    prototype: T;\n}\n\n/**\n * Check if a node is a component.\n * @param node The node to check.\n * @returns True if element is a custom element.\n */\nexport const isComponent = <T extends ComponentInstance>(node: T | Node): node is T => !!(node as WithComponentFlags<typeof node>)[COMPONENT_SYMBOL];\n\n/**\n * Check if a constructor is a component constructor.\n * @param constructor The constructor to check.\n * @returns True if the constructor is a component class.\n */\nexport const isComponentConstructor = <T extends ComponentInstance, C extends ComponentConstructor<T>>(constructor: Function | C): constructor is C => !!constructor.prototype[COMPONENT_SYMBOL];\n\n/**\n * Should emulate life cycle.\n */\nlet lifeCycleEmulation = typeof nativeCustomElements === 'undefined';\n\n/**\n * Flag the element for life cycle emulation.\n * @param node The element to flag.\n */\nexport const emulateLifeCycle = (node: WithComponentFlags<HTMLElement>) => {\n    lifeCycleEmulation = true;\n    node[EMULATE_LIFECYCLE_SYMBOL] = true;\n};\n\n/**\n * Life cycle emulation status.\n * @returns True if life cycle emulation is enabled.\n */\nexport const emulatingLifeCycle = () => lifeCycleEmulation;\n\n/**\n * Check if a node require emulated life cycle.\n * @param node The node to check.\n * @returns The node require emulated life cycle.\n */\nexport const shouldEmulateLifeCycle = <T extends HTMLElement>(node: WithComponentFlags<T | Element>): node is ComponentInstance<T> => !!node[EMULATE_LIFECYCLE_SYMBOL];\n\n/**\n * Invoke `connectedCallback` method of a Node (and its descendents).\n * It does nothing if life cycle is disabled.\n *\n * @param node The connected node.\n */\nexport const connect = (node: Node) => {\n    if (!isElement(node)) {\n        return;\n    }\n    if (shouldEmulateLifeCycle(node)) {\n        node.connectedCallback();\n    }\n    const children = cloneChildNodes(node.childNodes);\n    for (let i = 0, len = children.length; i < len; i++) {\n        connect(children[i]);\n    }\n};\n\n/**\n * Invoke `disconnectedCallback` method of a Node (and its descendents).\n * It does nothing if life cycle is disabled.\n *\n * @param node The disconnected node.\n */\nexport const disconnect = (node: Node) => {\n    if (!isElement(node)) {\n        return;\n    }\n    if (shouldEmulateLifeCycle(node)) {\n        node.disconnectedCallback();\n    }\n    const children = cloneChildNodes(node.childNodes);\n    for (let i = 0, len = children.length; i < len; i++) {\n        disconnect(children[i]);\n    }\n};\n\n/**\n * Extract slotted child nodes for initial child nodes.\n * @param element The compoonent instance.\n * @returns A list of new slotted children.\n */\nfunction initSlotChildNodes<T extends HTMLElement, C extends ComponentInstance<T>>(element: C) {\n    /* istanbul ignore next */\n    if (!element.childNodes.length && element.ownerDocument.readyState === 'loading') {\n        return;\n    }\n\n    const context = getHostContext(element) as Context;\n    const slotChildNodes = cloneChildNodes(element.childNodes);\n    for (let i = 0, len = slotChildNodes.length; i < len; i++) {\n        const child = slotChildNodes[i];\n        const childContext = getOrCreateContext(child);\n        DOM.removeChild(element, child, false);\n        childContext.hosts = [element];\n        childContext.parents = [context];\n    }\n    context.children = slotChildNodes;\n    return slotChildNodes;\n}\n\n/**\n * Create a base Component class which extends a native constructor.\n * @param ctor The base HTMLElement constructor to extend.\n * @returns The extend class.\n */\nconst mixin = <T extends HTMLElement>(ctor: Constructor<T>) => {\n    const Component = class Component extends (ctor as Constructor<HTMLElement>) {\n        /**\n         * An array containing the names of the attributes to observe.\n         * @returns The list of attributes to observe.\n         */\n        static get observedAttributes(): string[] {\n            const propertiesDescriptor = getProperties(this.prototype);\n            const attributes = [];\n            for (const key in propertiesDescriptor) {\n                const prop = propertiesDescriptor[key as keyof typeof propertiesDescriptor];\n                if (prop && prop.attribute && !prop.state) {\n                    attributes.push(prop.attribute);\n                }\n            }\n\n            return attributes;\n        }\n\n        /**\n         * Define component properties.\n         */\n        static readonly properties?: {\n            [key: string]: PropertyConfig;\n        };\n\n        /**\n         * Define component listeners.\n         */\n        static readonly listeners?: {\n            [key: string]: ListenerConfig;\n        };\n\n        /**\n         * Identify shimmed constructors.\n         * Constructor will skip native constructing when true.\n         */\n        static shim?: boolean;\n\n        /**\n         * Upgrade a plain element prototype.\n         * @param node The node to upgrade.\n         * @returns The new prototyped node.\n         */\n        static upgrade(node: HTMLElement) {\n            return new this(node);\n        }\n\n        /**\n         * A set of watched properties.\n         */\n        readonly watchedProperties: PropertyKey[] = [];\n\n        /**\n         * The tag name used for Component definition.\n         * @returns The custom element definition name.\n         */\n        get is(): string {\n            return undefined as unknown as string;\n        }\n\n        /**\n         * A flag with the connected value of the node.\n         * @returns True if the node is connected to the document.\n         */\n        get isConnected(): boolean {\n            return isConnected.call(this);\n        }\n\n        /**\n         * A list of slot nodes.\n         * @returns The list of slotted nodes.\n         */\n        get slotChildNodes() {\n            return (getHostContext(this) as Context).children;\n        }\n\n        /**\n         * Handle setting text content to component.\n         * @returns The element text content.\n         */\n        get textContent() {\n            return super.textContent;\n        }\n        set textContent(value) {\n            render(value, this);\n        }\n\n        /**\n         * Handle setting text content to component.\n         * @returns The element inner HTML.\n         */\n        get innerHTML() {\n            return super.innerHTML;\n        }\n        set innerHTML(value) {\n            render(parseDOM(value), this);\n            customElements.upgrade(this);\n        }\n\n        constructor(...args: any[]) {\n            super();\n\n            const node = isElement(args[0]) && args[0];\n            const element = (node ? (setPrototypeOf(node, this), node) : this) as this;\n\n            const context = getOrCreateHostContext(element);\n            if (element.parentNode) {\n                // custom element initialized by the parser\n                context.parents = [context];\n            }\n\n            // setup listeners\n            const computedListeners = getListeners(element).map((listener) => ({\n                ...listener,\n                callback: listener.callback.bind(element),\n            }));\n            setListeners(element, computedListeners);\n\n            for (let i = 0, len = computedListeners.length; i < len; i++) {\n                const { event, target, selector, callback, options } = computedListeners[i];\n                if (!target) {\n                    element.delegateEventListener(event, selector, callback, options);\n                }\n            }\n\n            // setup properties\n            const computedProperties = getProperties(element);\n            for (const propertyKey in computedProperties) {\n                delete element[propertyKey];\n                const property = computedProperties[propertyKey];\n                if (typeof property.initializer === 'function') {\n                    element[propertyKey] = property.initializer.call(element);\n                } else if (typeof property.defaultValue !== 'undefined') {\n                    element[propertyKey] = property.defaultValue;\n                }\n                if (property.static) {\n                    element.watchedProperties.push(propertyKey);\n                }\n            }\n\n            initSlotChildNodes(element);\n            element.initialize();\n            return element;\n        }\n\n        /**\n         * Initialize component properties.\n         * @deprecated\n         */\n        initialize() { }\n\n        /**\n         * Invoked each time the Component is appended into a document-connected element.\n         * This will happen each time the node is moved, and may happen before the element's contents have been fully parsed.\n         */\n        connectedCallback() {\n            if (!hasAttributeImpl.call(this, ':defined')) {\n                if (this.is !== this.localName) {\n                    // force the is attribute\n                    setAttributeImpl.call(this, 'is', this.is);\n                }\n                setAttributeImpl.call(this, ':defined', '');\n            }\n\n            const listeners = getListeners(this);\n            for (let i = 0, len = listeners.length; i < len; i++) {\n                const { event, target, callback, options } = listeners[i];\n                if (target) {\n                    target.addEventListener(event, callback, options);\n                }\n            }\n\n            // trigger a re-render when the Node is connected\n            this.forceUpdate();\n        }\n\n        /**\n         * Invoked each time the Component is disconnected from the document's DOM.\n         */\n        disconnectedCallback() {\n            const listeners = getListeners(this);\n            for (let i = 0, len = listeners.length; i < len; i++) {\n                const { event, target, callback, options } = listeners[i];\n                if (target) {\n                    target.removeEventListener(event, callback, options);\n                }\n            }\n        }\n\n        /**\n         * Invoked each time one of the Component's attributes is added, removed, or changed.\n         *\n         * @param attributeName The name of the updated attribute.\n         * @param oldValue The previous value of the attribute.\n         * @param newValue The new value for the attribute (null if removed).\n         */\n        attributeChangedCallback(attributeName: string, oldValue: null | string, newValue: string | null) {\n            reflectAttributeToProperty(this, attributeName, newValue);\n        }\n\n        /**\n         * Invoked each time one of a Component's state property is setted, removed, or changed.\n         *\n         * @param propertyName The name of the changed property.\n         * @param oldValue The previous value of the property.\n         * @param newValue The new value for the property (undefined if removed).\n         */\n        stateChangedCallback<P extends keyof this>(propertyName: P, oldValue: this[P] | undefined, newValue: this[P]) {\n            reflectPropertyToAttribute(this, propertyName, newValue);\n        }\n\n        /**\n         * Invoked each time one of a Component's property is setted, removed, or changed.\n         *\n         * @param propertyName The name of the changed property.\n         * @param oldValue The previous value of the property.\n         * @param newValue The new value for the property (undefined if removed).\n         */\n        propertyChangedCallback<P extends keyof this>(propertyName: P, oldValue: this[P] | undefined, newValue: this[P]) {\n            reflectPropertyToAttribute(this, propertyName, newValue);\n        }\n\n        /**\n         * Get the inner value of a property.\n         * This is an helper method for properties getters and setters.\n         * @param propertyName The name of the property to get.\n         * @returns The inner value of the property.\n         */\n        getInnerPropertyValue<P extends keyof this>(propertyName: P): this[P] {\n            const property = getProperty(this, propertyName, true);\n            return this[property.symbol as keyof this] as this[P];\n        }\n\n        /**\n         * Set the inner value of a property.\n         * This is an helper method for properties getters and setters.\n         * @param propertyName The name of the property to get.\n         * @param value The inner value to set.\n         */\n        setInnerPropertyValue<P extends keyof this>(propertyName: P, value: this[P]) {\n            const property = getProperty(this, propertyName, true);\n            this[property.symbol as keyof this] = value;\n        }\n\n        /**\n         * Observe a Component Property.\n         *\n         * @param propertyName The name of the Property to observe\n         * @param observer The callback function\n         */\n        observe<P extends keyof this>(propertyName: P, observer: PropertyObserver<this[P]>) {\n            addObserver(this, propertyName, observer);\n        }\n\n        /**\n         * Unobserve a Component Property.\n         *\n         * @param propertyName The name of the Property to unobserve\n         * @param observer The callback function to remove\n         */\n        unobserve<P extends keyof this>(propertyName: P, observer: PropertyObserver<this[P]>) {\n            removeObserver(this, propertyName, observer);\n        }\n\n        /**\n         * Dispatch a custom Event.\n         *\n         * @param event The event to dispatch or the name of the synthetic event to create.\n         * @param detail Detail object of the event.\n         * @param bubbles Should the event bubble.\n         * @param cancelable Should the event be cancelable.\n         * @param composed Is the event composed.\n         */\n        dispatchEvent(event: Event): boolean;\n        dispatchEvent(event: string, detail?: CustomEventInit['detail'], bubbles?: boolean, cancelable?: boolean, composed?: boolean): boolean;\n        dispatchEvent(event: Event | string, detail?: CustomEventInit['detail'], bubbles?: boolean, cancelable?: boolean, composed?: boolean) {\n            return dispatchEvent(this, event as string, detail, bubbles, cancelable, composed);\n        }\n\n        /**\n         * Dispatch an async custom Event.\n         *\n         * @param event The event to dispatch or the name of the synthetic event to create.\n         * @param detail Detail object of the event.\n         * @param bubbles Should the event bubble.\n         * @param cancelable Should the event be cancelable.\n         * @param composed Is the event composed.\n         */\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        dispatchAsyncEvent(event: Event): Promise<any[]>;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        dispatchAsyncEvent(event: string, detail?: CustomEventInit['detail'], bubbles?: boolean, cancelable?: boolean, composed?: boolean): Promise<any[]>;\n        dispatchAsyncEvent(event: Event | string, detail?: CustomEventInit['detail'], bubbles?: boolean, cancelable?: boolean, composed?: boolean) {\n            return dispatchAsyncEvent(this, event as string, detail, bubbles, cancelable, composed);\n        }\n\n        /**\n         * Delegate an Event listener.\n         * @param event The event name to listen.\n         * @param selector The selector to delegate.\n         * @param callback The callback to trigger when an Event matches the delegation.\n         * @param options Add event listener options.\n         */\n        delegateEventListener(event: string, selector: string | null, callback: DelegatedEventCallback, options?: AddEventListenerOptions) {\n            delegateEventListener(this, event, selector, callback, options);\n        }\n\n        /**\n         * Remove an Event delegation.\n         *\n         * @param event The Event name to undelegate.\n         * @param selector The selector to undelegate.\n         * @param callback The callback to remove,\n         */\n        undelegateEventListener(event: string, selector: string | null, callback: DelegatedEventCallback) {\n            undelegateEventListener(this, event, selector, callback);\n        }\n\n        /**\n         * Render method of the Component.\n         *\n         * @returns The instances of the rendered Components and/or Nodes\n         */\n        render(): Template | undefined {\n            return this.slotChildNodes;\n        }\n\n        /**\n         * Force an element to re-render.\n         */\n        forceUpdate() {\n            const childNodes = this.slotChildNodes || initSlotChildNodes(this);\n            if (childNodes) {\n                internalRender(\n                    this,\n                    this.render(),\n                    false,\n                    getOrCreateContext(this),\n                    this\n                );\n            }\n        }\n\n        /**\n         * Append a child to the Component.\n         *\n         * @param newChild The child to add.\n         * @returns The appended child.\n         */\n        appendChild<T extends Node>(newChild: T): T {\n            return DOM.appendChild(this, newChild);\n        }\n\n        /**\n         * Remove a child from the Component.\n         *\n         * @param oldChild The child to remove.\n         * @returns The removed node.\n         */\n        removeChild<T extends Node>(oldChild: T): T {\n            return DOM.removeChild(this, oldChild);\n        }\n\n        /**\n         * Insert a child before another in the Component.\n         *\n         * @param newChild The child to insert.\n         * @param refChild The referred node.\n         * @returns The inserted child.\n         */\n        insertBefore<T extends Node>(newChild: T, refChild: Node | null): T {\n            return DOM.insertBefore(this, newChild, refChild);\n        }\n\n        /**\n         * Replace a child with another in the Component.\n         *\n         * @param newChild The child to insert.\n         * @param oldChild The Node to replace.\n         * @returns The replaced node.\n         */\n        replaceChild<T extends Node>(newChild: Node, oldChild: T): T {\n            return DOM.replaceChild(this, newChild, oldChild);\n        }\n\n        /**\n         * Insert a child at the given position.\n         * @param position The position of the insertion.\n         * @param insertedElement The child to insert.\n         * @returns The inserted child.\n         */\n        insertAdjacentElement(position: InsertPosition, insertedElement: Element): Element | null {\n            return DOM.insertAdjacentElement(this, position, insertedElement);\n        }\n\n        /**\n         * Set a Component attribute.\n         * @param qualifiedName The attribute name.\n         * @param value The value to set.\n         */\n        setAttribute(qualifiedName: string, value: string) {\n            DOM.setAttribute(this, qualifiedName, value);\n        }\n\n        /**\n         * Remove a Component attribute.\n         * @param qualifiedName The attribute name.\n         */\n        removeAttribute(qualifiedName: string) {\n            DOM.removeAttribute(this, qualifiedName);\n        }\n    };\n\n    defineProperty(Component.prototype, COMPONENT_SYMBOL, {\n        get() {\n            return true;\n        },\n    });\n\n    return Component as ComponentConstructor<ComponentInstance<T>>;\n};\n\n/**\n * Create a shim Constructor for Element constructors, in order to extend and instantiate them programmatically,\n * because using `new HTMLElement()` in browsers throw `Illegal constructor`.\n *\n * @param base The constructor or the class to shim.\n * @returns A newable constructor with the same prototype.\n */\nexport const shim = <T extends { new(): HTMLElement; prototype: HTMLElement }>(base: T): T => {\n    type Component = ComponentInstance<InstanceType<T>>;\n    type Constrcutor = ComponentConstructor<Component>;\n\n    const shim = function ShimComponent(this: Component, ...args: any[]) {\n        const constructor = this.constructor as Constrcutor;\n        const is = this.is;\n        if (!is) {\n            throw new TypeError('Illegal constructor');\n        }\n\n        const tag = customElements.tagNames[is];\n        let element: Component;\n        if (customElements.native && !constructor.shim) {\n            element = Reflect.construct(base, args, constructor);\n            if (tag === element.localName) {\n                return element;\n            }\n        }\n\n        element = createElementImpl(tag) as Component;\n        setPrototypeOf(element, constructor.prototype);\n        emulateLifeCycle(element);\n        return element;\n    } as unknown as T;\n    setPrototypeOf(shim, base);\n    (shim as Function).apply = Function.apply;\n    (shim as Function).call = Function.call;\n    shim.prototype = base.prototype;\n    return shim;\n};\n\n/**\n * Get a native HTMLElement constructor to extend by its name.\n * @param constructor The constructor (eg. \"HTMLAnchorElement\") to extend.\n * @returns A proxy that extends the native constructor.\n */\nexport const extend = <T extends HTMLElement>(constructor: Constructor<T>) => mixin(shim(constructor));\n\n/**\n * The DNA base Component constructor, a Custom Element constructor with\n * declarative properties and event delegations, custom template and\n * a complete life cycle implementation.\n * All DNA components **must** extends this class.\n */\nexport const Component = extend(HTMLElementConstructor);\n\n/**\n * Decorate a component class in order to watch decorated properties.\n * @param constructor The component class to decorate.\n * @returns The decorated component class.\n */\nconst decorateConstructor = <T extends ComponentConstructor>(constructor: T) =>\n    class Component extends (constructor as ComponentConstructor) {\n        /**\n         * @inheritdoc\n         */\n        constructor(...args: any[]) {\n            super(...args);\n\n            const properties = getProperties(Component.prototype) as PropertiesOf<this>;\n            for (const propertyKey in properties) {\n                this.watchedProperties.push(propertyKey);\n            }\n        }\n    };\n\n/**\n * Decorate a component prototype class.\n * @param classOrDescriptor The component class to decorate.\n * @returns The decorated component class.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const customElementPrototype = <T extends ComponentConstructor>(classOrDescriptor: T | ClassDescriptor): any => {\n    if (typeof classOrDescriptor === 'function') {\n        // typescript\n        return decorateConstructor(classOrDescriptor);\n    }\n\n    // spec 2\n    const { kind, elements } = classOrDescriptor;\n    return {\n        kind,\n        elements,\n        finisher(constructor: Function) {\n            return decorateConstructor(constructor as T);\n        },\n    };\n};\n\n/**\n * Decorate and define a component class.\n * @param name The name of the custom element.\n * @param options The custom element options.\n * @returns The decorated component class.\n */\nexport const customElement = (name: string, options?: ElementDefinitionOptions) =>\n    // TypeScript complains about return type because we handle babel output\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    <T extends ComponentConstructor>(classOrDescriptor: T|ClassDescriptor): any => {\n        if (typeof classOrDescriptor === 'function') {\n            // typescript\n            const Component = decorateConstructor(classOrDescriptor);\n            customElements.define(name, Component, options);\n            return Component;\n        }\n\n        // spec 2\n        const { kind, elements } = classOrDescriptor;\n        return {\n            kind,\n            elements,\n            finisher(constructor: Function) {\n                const Component = decorateConstructor(constructor as T);\n                customElements.define(name, Component, options);\n                return Component;\n            },\n        };\n    };\n", "import type { Constructor } from './helpers';\nimport { isConnected, defineProperty, HTMLElementConstructor, document, nativeCustomElements } from './helpers';\nimport { connect, isComponent, isComponentConstructor } from './Component';\nimport { defineProperties } from './property';\nimport { defineListeners } from './events';\n\n/**\n * Check the validity of a Custom Element name.\n * @param name The name to validate.\n * @returns True if the name is valid.\n */\nconst assertValidateCustomElementName = (name: string): boolean => (\n    !!name                     // missing element name\n    && name.indexOf('-') >= 1  // custom element names must contain (and must not start with) a hyphen\n    && /[a-z\\-\\d]/.test(name)  // custom element names can contain lowercase characters, digits and hyphens\n    && /^[^\\d]/i.test(name)    // custom element names must not start with a digit\n);\n\n/**\n * The plain Custom Element interface.\n */\nexport type CustomElement<T extends HTMLElement = HTMLElement> = T & {\n    /**\n     * The tag name used for element definition.\n     */\n    is: string;\n\n    /**\n     * Invoked each time the element is appended into a document-connected element.\n     * This will happen each time the node is moved, and may happen before the element's contents have been fully parsed.\n     */\n    connectedCallback(): void;\n\n    /**\n     * Invoked each time the element is disconnected from the document's DOM.\n     */\n    disconnectedCallback(): void;\n\n    /**\n     * Invoked each time one of the elements's attributes is added, removed, or changed.\n     *\n     * @param attributeName The name of the updated attribute.\n     * @param oldValue The previous value of the attribute.\n     * @param newValue The new value for the attribute (null if removed).\n     */\n    attributeChangedCallback(attrName: string, oldValue: null | string, newValue: null | string): void;\n}\n\n/**\n * The plain Custom Element constructor.\n */\nexport type CustomElementConstructor<T extends CustomElement = CustomElement> = Constructor<T> & {\n    /**\n     * An array containing the names of the attributes to observe.\n     */\n    readonly observedAttributes?: string[];\n}\n\nexport type CustomElementRegistryMap = Record<string, CustomElementConstructor>;\n\n/**\n * Check if the function is a Custom Element constructor.\n * @param constructor The function to check.\n * @returns True if the function is a Custom Element constructor.\n */\nexport const isCustomElementConstructor = <T extends CustomElementConstructor>(constructor: Function|T): constructor is T => constructor.prototype instanceof HTMLElementConstructor;\n\n/**\n * The CustomElementRegistry interface provides methods for registering custom elements and querying registered elements.\n */\nexport class CustomElementRegistry {\n    /**\n     * Support native registry.\n     */\n    readonly native: boolean = !!nativeCustomElements;\n\n    /**\n     * A global registry.\n     */\n    readonly registry: CustomElementRegistryMap = {};\n\n    /**\n     * A map of tag names.\n     */\n    readonly tagNames: {\n        [key: string]: string;\n    } = {};\n\n    /**\n     * Collect \"whenDefined\" promises.\n     */\n    readonly queue: {\n        [key: string]: Array<(value?: unknown) => void>;\n    } = {};\n\n    /**\n     * Create registry instance.\n     */\n    constructor() {\n        document.addEventListener('DOMContentLoaded', () => {\n            this.upgrade(document.body);\n        });\n    }\n\n    /**\n     * Get the Custom Element definition for a tag.\n     *\n     * @param name The name of the tag.\n     * @returns The definition for the given tag.\n     */\n    get<K extends keyof CustomElementRegistryMap>(name: K): CustomElementRegistryMap[K] {\n        let constructor = this.registry[name];\n        // the native custom elements get method is slow\n        // assert valid names before calling it.\n        if (!constructor && nativeCustomElements && assertValidateCustomElementName(name)) {\n            constructor = nativeCustomElements.get(name) as typeof constructor;\n        }\n        return constructor;\n    }\n\n    /**\n     * Define a new Custom Element.\n     *\n     * @param name The tag name for the element.\n     * @param constructor The Custom Element constructor.\n     * @param options A set of definition options, like `extends` for native tag extension.\n     * @throws If the name is not valid.\n     * @throws If the constructor is not a function.\n     * @throws If the name has already been registered.\n     */\n    define<T extends CustomElementConstructor>(name: keyof CustomElementRegistryMap, constructor: T, options: ElementDefinitionOptions = {}) {\n        if (!assertValidateCustomElementName(name)) {\n            throw new SyntaxError('The provided name must be a valid Custom Element name');\n        }\n\n        if (typeof (constructor as unknown) !== 'function') {\n            throw new TypeError('The referenced constructor must be a constructor');\n        }\n\n        if (this.registry[name]) {\n            throw new Error('The registry already contains an entry with the same name');\n        }\n\n        if (isComponentConstructor(constructor)) {\n            defineProperties(constructor.prototype);\n            defineListeners(constructor.prototype);\n        }\n\n        try {\n            defineProperty(constructor.prototype, 'is', {\n                writable: false,\n                configurable: false,\n                value: name,\n            });\n        } catch {\n            throw new Error('The registry already contains an entry with the constructor (or is otherwise already defined)');\n        }\n\n        const tagName = (options.extends || name).toLowerCase();\n        this.registry[name] = constructor;\n        this.tagNames[name] = tagName;\n\n        if (nativeCustomElements) {\n            const shouldShim = (constructor as { shim?: boolean }).shim;\n            if (tagName !== name) {\n                (constructor as { shim?: boolean }).shim = true;\n                options = {\n                    get extends() {\n                        (constructor as { shim?: boolean }).shim = shouldShim;\n                        return tagName;\n                    },\n                };\n            }\n            nativeCustomElements.define(name, constructor, options);\n        } else {\n            const queue = this.queue;\n            if (document.body) {\n                this.upgrade(document.body);\n            }\n            const elementQueue = queue[name];\n            if (elementQueue) {\n                for (let i = 0, len = elementQueue.length; i < len; i++) {\n                    elementQueue[i](constructor);\n                }\n            }\n        }\n    }\n\n    /**\n     * It returns a Promise that resolves when the named element is defined.\n     * @param name The Custom Element name.\n     * @returns A Promise that resolves when the named element is defined.\n     */\n    whenDefined<K extends keyof CustomElementRegistryMap>(name: K): Promise<CustomElementRegistryMap[K]> {\n        if (nativeCustomElements) {\n            return nativeCustomElements\n                .whenDefined(name)\n                // not all browsers resolve the constructor class\n                .then(() => nativeCustomElements.get(name) as CustomElementRegistryMap[K]);\n        }\n        if (this.registry[name]) {\n            return Promise.resolve(this.registry[name]);\n        }\n        const queue = this.queue;\n        const whenDefinedPromise = new Promise((resolve) => {\n            queue[name] = queue[name] || [];\n            queue[name].push(resolve);\n        });\n\n        return whenDefinedPromise as Promise<CustomElementRegistryMap[K]>;\n    }\n\n    /**\n     * It upgrades all custom elements in a subtree even before they are connected to the main document.\n     * @param root A Node instance with descendant elements that are to be upgraded.\n     */\n    upgrade(root: HTMLElement) {\n        const is = (root.getAttribute('is') || root.tagName).toLowerCase();\n        const constructor = this.get(is);\n        // find all root children\n        const nodes = root.children;\n        // iterate all nodes found\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i] as HTMLElement;\n            if (node) {\n                this.upgrade(node);\n            }\n        }\n        if (!constructor) {\n            return;\n        }\n\n        if (nativeCustomElements && 'upgrade' in nativeCustomElements) {\n            // native upgrade\n            nativeCustomElements.upgrade(root);\n        }\n\n        // check if already instantiated\n        if (isComponent(root)) {\n            root.forceUpdate();\n            return;\n        }\n\n        if (isComponentConstructor(constructor)) {\n            const attributes: { name: string; value: string }[] = [];\n            const observed = constructor.observedAttributes || [];\n            for (let i = 0, len = root.attributes.length; i < len; i++) {\n                const attr = root.attributes[i];\n                if (observed.indexOf(attr.name) !== -1) {\n                    attributes.push({\n                        name: attr.name,\n                        value: attr.value,\n                    });\n                }\n            }\n            const element = constructor.upgrade(root);\n            for (let i = 0, len = attributes.length; i < len; i++) {\n                const { name, value } = attributes[i];\n                if (element.getAttribute(name) === value) {\n                    element.attributeChangedCallback(name, null, value);\n                } else {\n                    element.setAttribute(name, value);\n                }\n            }\n            if (isConnected.call(element)) {\n                connect(element);\n            }\n            element.forceUpdate();\n        }\n    }\n}\n\n/**\n * The global DNA registry instance.\n */\nexport const customElements = new CustomElementRegistry();\n"],
  "mappings": "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",
  "names": ["jsdom", "namespace", "jsd", "throwPlatform", "NodeConstructor", "HTMLElementConstructor", "EventConstructor", "CustomEventConstructor", "document", "namespace", "DOCUMENT_NODE", "TEXT_NODE", "COMMENT_NODE", "ELEMENT_NODE", "isArray", "getOwnPropertyDescriptor", "getPropertyDescriptor", "object", "propertyKey", "getPrototypeOf", "setPrototypeOf", "prototype", "hasOwnProperty", "defineProperty", "appendChildImpl", "NodeConstructor", "removeChildImpl", "insertBeforeImpl", "replaceChildImpl", "insertAdjacentElementImpl", "HTMLElementConstructor", "isConnectedImpl", "getOwnPropertyDescriptor", "getAttributeImpl", "hasAttributeImpl", "setAttributeImpl", "removeAttributeImpl", "matchesImpl", "createDocumentFragmentImpl", "document", "createElementImpl", "createElementNSImpl", "createTextNodeImpl", "createCommentImpl", "createEventImpl", "typeArg", "eventInitDict", "event", "CustomEventConstructor", "isNode", "target", "isDocument", "node", "DOCUMENT_NODE", "isText", "TEXT_NODE", "isElement", "ELEMENT_NODE", "isEvent", "EventConstructor", "isConnected", "parent", "nativeCustomElements", "namespace", "cloneChildNodes", "arr", "result", "i", "PROPERTIES_SYMBOL", "OBSERVERS_SYMBOL", "getProperties", "prototype", "chain", "props", "hasOwnProperty", "getProperty", "propertyKey", "failIfMissing", "property", "extractTypes", "declaration", "type", "isArray", "defineProperty", "symbolKey", "isStatic", "symbol", "hasAttribute", "declarations", "attribute", "event", "state", "update", "acceptsBoolean", "acceptsNumber", "acceptsString", "newValue", "valueType", "get", "set", "getter", "setter", "validate", "finalDescriptor", "value", "isComponent", "oldValue", "valid", "Type", "observers", "getPropertyObservers", "i", "len", "observer", "addObserver", "defineProperties", "handled", "constructor", "ctr", "HTMLElementConstructor", "propertiesDescriptor", "getOwnPropertyDescriptor", "descriptorProperties", "config", "getPrototypeOf", "getPropertyForAttribute", "attributeName", "properties", "reflectPropertyToAttribute", "element", "propertyName", "toAttribute", "reflectAttributeToProperty", "name", "fromAttribute", "assignFromDescriptor", "descriptor", "initializer", "createProperty", "targetOrClassElement", "key", "createObserver", "methodKey", "getObservers", "result", "removeObserver", "io", "observe", "CONTEXT_SYMBOL", "HOST_CONTEXT_SYMBOL", "createContext", "node", "getContext", "getOrCreateContext", "getHostContext", "getOrCreateHostContext", "removeHosts", "newHost", "node", "childContext", "getOrCreateContext", "hosts", "parentContext", "getHostContext", "parents", "i", "len", "hostContext", "getContext", "DOM", "createDocumentFragmentImpl", "qualifiedName", "options", "name", "createElementImpl", "constructor", "customElements", "isComponentConstructor", "namespaceURI", "createElementNSImpl", "createTextNodeImpl", "data", "createCommentImpl", "typeArg", "eventInitDict", "createEventImpl", "parent", "newChild", "slot", "isComponent", "update", "oldParent", "context", "slotted", "previousIndex", "appendChildImpl", "emulatingLifeCycle", "isConnected", "connect", "oldChild", "oldChildContext", "io", "connected", "childNodes", "removeChildImpl", "disconnect", "refChild", "refIndex", "parentNode", "oldIo", "insertBeforeImpl", "replaceChildImpl", "position", "insertedElement", "insertAdjacentElementImpl", "element", "getAttributeImpl", "hasAttributeImpl", "value", "shouldEmulateLifeCycle", "observedAttributes", "setAttributeImpl", "oldValue", "removeAttributeImpl", "EVENT_CALLBACKS_SYMBOL", "assertNode", "element", "isElement", "assertEvent", "event", "isEvent", "assertEventName", "eventName", "assertEventSelector", "selector", "assertEventCallback", "callback", "assertEventBubbles", "bubbles", "assertEventCancelable", "cancelable", "assertEventComposed", "composed", "delegateEventListener", "options", "delegatedElement", "delegations", "callbacks", "descriptors", "eventTarget", "originalStopPropagation", "originalImmediatePropagation", "stopped", "stoppedImmediated", "filtered", "i", "selectorTarget", "target", "matchesImpl", "lastTarget", "match1", "match2", "undelegateEventListener", "listener", "descriptor", "initEvent", "detail", "createEventImpl", "dispatchEvent", "HTMLElementConstructor", "dispatchAsyncEvent", "asyncEvent", "promises", "LISTENERS_SYMBOL", "getListeners", "prototype", "listeners", "hasOwnProperty", "setListeners", "defineListener", "defineListeners", "constructor", "ctr", "listenersDescriptor", "getOwnPropertyDescriptor", "listenersGetter", "listenerDescriptors", "eventPath", "paths", "getPrototypeOf", "createListener", "targetOrClassElement", "methodKey", "method", "isEventTarget", "listen", "n", "t", "s", "r", "e", "u", "h", "p", "a", "htm_default", "l", "V_SYM", "Fragment", "isVObject", "target", "isVFragment", "isVFunction", "isCustomElementConstructor", "isVComponent", "isVNode", "isNode", "isVSlot", "isVTag", "h", "tagOrComponent", "properties", "children", "propertiesChildren", "normalizedProperties", "key", "is", "xmlns", "ref", "k", "isArray", "customElements", "jsx", "jsxs", "THENABLE_SYMBOL", "isThenable", "target", "getThenableState", "state", "newState", "result", "error", "SUBSCRIPTION_SYMBOL", "isObservable", "target", "getObservableState", "state", "newState", "value", "error", "CACHE", "HOST_REGEX", "CSS_COMMENTS_REGEX", "CSS_SELECTORS_REGEX", "css", "name", "cssText", "extend", "cached", "scope", "fullMatch", "mod", "match", "selector", "innerHtml", "htm_default", "h", "compile", "string", "array", "html", "values", "convertClasses", "value", "classes", "k", "convertStyles", "styles", "propertyKey", "camelName", "match", "propValue", "ruleMap", "ruleString", "rulePair", "isRenderingInput", "element", "setValue", "isListenerProperty", "getCurrentNode", "context", "getCurrentContext", "currentNode", "getHostContext", "getContext", "getKeyedNode", "key", "hasKeyedNode", "node", "addKeyedNode", "renderTemplate", "parent", "slot", "root", "rootContext", "template", "filter", "isObject", "isArray", "childCount", "i", "len", "templateNode", "templateContext", "templateChildren", "templateNamespace", "isVObject", "isVFragment", "isVFunction", "Function", "properties", "children", "rootFragment", "placeholder", "renderContext", "getOrCreateContext", "DOM", "isAttached", "running", "requestUpdate", "internalRender", "isVSlot", "hostContext", "slotted", "name", "item", "slotContext", "isElement", "namespaceURI", "currentContext", "isNew", "isVComponent", "isVTag", "isVNode", "oldProperties", "oldValue", "style", "oldStyles", "newStyles", "classList", "newClasses", "oldClasses", "className", "eventName", "type", "wasType", "isReference", "observedAttributes", "descriptor", "getPropertyDescriptor", "property", "getProperty", "attrValue", "isThenable", "h", "props", "status", "getThenableState", "isObservable", "observable", "getObservableState", "subscription", "isNode", "css", "customElements", "isText", "isComponent", "namespace", "fragment", "childNodes", "previousFragment", "previousNamespace", "previousIndex", "lastNode", "currentIndex", "lastIndex", "render", "input", "isComponentRoot", "DOMParse", "props", "context", "source", "store", "wrapper", "DOM", "customElements", "dom", "cloneChildNodes", "parseDOM", "string", "h", "until", "thenable", "template", "original", "getThenableState", "state", "COMPONENT_SYMBOL", "EMULATE_LIFECYCLE_SYMBOL", "isComponent", "node", "isComponentConstructor", "constructor", "lifeCycleEmulation", "nativeCustomElements", "emulateLifeCycle", "emulatingLifeCycle", "shouldEmulateLifeCycle", "connect", "isElement", "children", "cloneChildNodes", "i", "len", "disconnect", "initSlotChildNodes", "element", "context", "getHostContext", "slotChildNodes", "child", "childContext", "getOrCreateContext", "DOM", "mixin", "ctor", "Component", "args", "setPrototypeOf", "getOrCreateHostContext", "computedListeners", "getListeners", "listener", "setListeners", "event", "target", "selector", "callback", "options", "computedProperties", "getProperties", "propertyKey", "property", "propertiesDescriptor", "attributes", "key", "prop", "isConnected", "value", "render", "parseDOM", "customElements", "hasAttributeImpl", "setAttributeImpl", "listeners", "attributeName", "oldValue", "newValue", "reflectAttributeToProperty", "propertyName", "reflectPropertyToAttribute", "getProperty", "observer", "addObserver", "removeObserver", "detail", "bubbles", "cancelable", "composed", "dispatchEvent", "dispatchAsyncEvent", "delegateEventListener", "undelegateEventListener", "internalRender", "newChild", "oldChild", "refChild", "position", "insertedElement", "qualifiedName", "defineProperty", "shim", "base", "is", "tag", "createElementImpl", "extend", "HTMLElementConstructor", "decorateConstructor", "properties", "customElementPrototype", "classOrDescriptor", "kind", "elements", "customElement", "name", "assertValidateCustomElementName", "name", "isCustomElementConstructor", "constructor", "HTMLElementConstructor", "CustomElementRegistry", "nativeCustomElements", "document", "options", "isComponentConstructor", "defineProperties", "defineListeners", "defineProperty", "tagName", "shouldShim", "queue", "elementQueue", "i", "len", "resolve", "root", "is", "nodes", "node", "isComponent", "attributes", "observed", "attr", "element", "value", "isConnected", "connect", "customElements"]
}
