import type { Constructor } from './helpers';
/**
 * The plain Custom Element interface.
 */
export type CustomElement<T extends HTMLElement = HTMLElement> = T & {
    /**
     * The tag name used for element definition.
     */
    is: string;
    /**
     * Invoked each time the element is appended into a document-connected element.
     * This will happen each time the node is moved, and may happen before the element's contents have been fully parsed.
     */
    connectedCallback(): void;
    /**
     * Invoked each time the element is disconnected from the document's DOM.
     */
    disconnectedCallback(): void;
    /**
     * Invoked each time one of the elements's attributes is added, removed, or changed.
     *
     * @param attributeName The name of the updated attribute.
     * @param oldValue The previous value of the attribute.
     * @param newValue The new value for the attribute (null if removed).
     */
    attributeChangedCallback(attrName: string, oldValue: null | string, newValue: null | string): void;
};
/**
 * The plain Custom Element constructor.
 */
export type CustomElementConstructor<T extends CustomElement = CustomElement> = Constructor<T> & {
    /**
     * An array containing the names of the attributes to observe.
     */
    readonly observedAttributes?: string[];
};
export type CustomElementRegistryMap = Record<string, CustomElementConstructor>;
/**
 * Check if the function is a Custom Element constructor.
 * @param constructor The function to check.
 * @returns True if the function is a Custom Element constructor.
 */
export declare const isCustomElementConstructor: <T extends CustomElementConstructor<CustomElement<HTMLElement>>>(constructor: Function | T) => constructor is T;
/**
 * The CustomElementRegistry interface provides methods for registering custom elements and querying registered elements.
 */
export declare class CustomElementRegistry {
    /**
     * Support native registry.
     */
    readonly native: boolean;
    /**
     * A global registry.
     */
    readonly registry: CustomElementRegistryMap;
    /**
     * A map of tag names.
     */
    readonly tagNames: {
        [key: string]: string;
    };
    /**
     * Collect "whenDefined" promises.
     */
    readonly queue: {
        [key: string]: Array<(value?: unknown) => void>;
    };
    /**
     * Create registry instance.
     */
    constructor();
    /**
     * Get the Custom Element definition for a tag.
     *
     * @param name The name of the tag.
     * @returns The definition for the given tag.
     */
    get<K extends keyof CustomElementRegistryMap>(name: K): CustomElementRegistryMap[K];
    /**
     * Define a new Custom Element.
     *
     * @param name The tag name for the element.
     * @param constructor The Custom Element constructor.
     * @param options A set of definition options, like `extends` for native tag extension.
     * @throws If the name is not valid.
     * @throws If the constructor is not a function.
     * @throws If the name has already been registered.
     */
    define<T extends CustomElementConstructor>(name: keyof CustomElementRegistryMap, constructor: T, options?: ElementDefinitionOptions): void;
    /**
     * It returns a Promise that resolves when the named element is defined.
     * @param name The Custom Element name.
     * @returns A Promise that resolves when the named element is defined.
     */
    whenDefined<K extends keyof CustomElementRegistryMap>(name: K): Promise<CustomElementRegistryMap[K]>;
    /**
     * It upgrades all custom elements in a subtree even before they are connected to the main document.
     * @param root A Node instance with descendant elements that are to be upgraded.
     */
    upgrade(root: HTMLElement): void;
}
/**
 * The global DNA registry instance.
 */
export declare const customElements: CustomElementRegistry;
