import type { Constructor } from './helpers';
import type { Members, ComponentInstance } from './Component';
/**
 * A Symbol which contains all Property instances of a Component.
 */
declare const PROPERTIES_SYMBOL: unique symbol;
/**
 * A Symbol which contains all Property observers of a Component.
 */
declare const OBSERVERS_SYMBOL: unique symbol;
/**
 * Retrieve properties declarations of a Component.
 */
export type PropertiesOf<T extends ComponentInstance> = {
    [P in keyof Members<T>]: Property<T, P>;
};
/**
 * Retrieve properties declarations of a Component.
 */
export type ObserversOf<T extends ComponentInstance> = {
    [P in keyof PropertiesOf<T>]: PropertyObserver<T[P]>[];
};
/**
 * A prototype with properties.
 */
export type WithProperties<T extends ComponentInstance> = T & {
    [PROPERTIES_SYMBOL]?: PropertiesOf<T>;
};
/**
 * A prototype with observers.
 */
export type WithObservers<T extends ComponentInstance> = T & {
    [OBSERVERS_SYMBOL]?: ObserversOf<T>;
};
/**
 * The observer signature for properties.
 *
 * @param oldValue The previous value of the property.
 * @param newValue The current value of the property.
 */
export type PropertyObserver<TypeHint = unknown> = (oldValue: TypeHint | undefined, newValue: TypeHint, propertyKey: string) => void;
/**
 * Convert constructor types to their normalised instance types.
 */
type ConvertConstructorTypes<C extends Constructor<unknown>, T = InstanceType<C>> = T extends Number ? number : T extends String ? string : T extends Boolean ? boolean : T extends unknown[] ? any[] : T extends Object ? any : T;
/**
 * A state property declaration.
 */
export type PropertyDeclaration<TypeConstructorHint extends Constructor<any> = Constructor<any>> = PropertyDescriptor & {
    /**
     * The property private symbol.
     */
    symbol?: symbol;
    /**
     * Flag state properties.
     */
    state?: boolean;
    /**
     * The property is bound to an attribute. Also specifies the attribute name if different from the property.
     */
    attribute?: boolean | string;
    /**
     * The event to fire on property change.
     */
    event?: true | string;
    /**
     * Property change should trigger component update.
     */
    update?: boolean;
    /**
     * Convert attribute to property value.
     *
     * @param value The attributue value.
     * @returns The property value.
     */
    fromAttribute?: (value: string | null) => ConvertConstructorTypes<TypeConstructorHint> | undefined;
    /**
     * Convert property to attribute value.
     * @param value The property value.
     * @returns The attributue value.
     */
    toAttribute?: (value: ConvertConstructorTypes<TypeConstructorHint>) => string | null | undefined;
    /**
     * The initial value of the property.
     */
    defaultValue?: ConvertConstructorTypes<TypeConstructorHint>;
    /**
     * A list of valid property values prototypes.
     */
    type?: TypeConstructorHint | TypeConstructorHint[];
    /**
     * Define a property observable.
     */
    observe?: PropertyObserver<ConvertConstructorTypes<TypeConstructorHint>>;
    /**
     * A list of field observables.
     */
    observers?: PropertyObserver<ConvertConstructorTypes<TypeConstructorHint>>[];
    /**
     * A custom validation function for the property.
     * Property assignement throws when this function returns falsy values.
     */
    validate?: (value: unknown) => boolean;
    /**
     * Native custom getter for the property.
     */
    get?: PropertyDescriptor['get'];
    /**
     * Native custom setter for the property.
     */
    set?: PropertyDescriptor['set'];
    /**
     * Define custom getter for the property.
     * @param value The current property value.
     */
    getter?: (value?: ConvertConstructorTypes<TypeConstructorHint>) => ReturnType<NonNullable<PropertyDescriptor['get']>>;
    /**
     * Define a custom setter for the property.
     * It runs before property validations.
     * The returned value will be set to the property.
     * @param newValue The value to set.
     */
    setter?: (newValue?: Parameters<NonNullable<PropertyDescriptor['set']>>[0]) => ConvertConstructorTypes<TypeConstructorHint>;
    /**
     * The initializer function.
     */
    initializer?: Function;
};
/**
 * Property configuration for properties accessor.
 */
export type PropertyConfig<TypeConstructorHint extends Constructor<unknown> = Constructor<unknown>> = PropertyDeclaration<TypeConstructorHint> | TypeConstructorHint | TypeConstructorHint[];
/**
 * A property instance.
 */
export type Property<T extends ComponentInstance, P extends keyof Members<T>> = PropertyDescriptor & {
    /**
     * The property name of the field.
     */
    readonly name: P;
    /**
     * The property has been defined using static getter.
     */
    readonly static: boolean;
    /**
     * The property private symbol.
     */
    symbol: symbol;
    /**
     * Flag state properties.
     */
    state: boolean;
    /**
     * The bound attribute name.
     */
    attribute?: string;
    /**
     * The event to fire on property change.
     */
    event?: string;
    /**
     * Property change should trigger component update.
     */
    update?: boolean;
    /**
     * The initial value of the property.
     */
    defaultValue?: T[P];
    /**
     * A list of valid property values prototypes.
     */
    type: Constructor<T[P]>[];
    /**
     * Convert attribute to property value.
     *
     * @param value The attributue value.
     * @returns The property value.
     */
    fromAttribute?: (value: string | null) => T[P];
    /**
     * Convert property to attribute value.
     * @param value The property value.
     * @returns The attributue value.
     */
    toAttribute?: (value: T[P]) => string | null | undefined;
    /**
     * A custom validation function for the property.
     * Property assignement throws when this function returns falsy values.
     */
    validate?: (value: unknown) => boolean;
    /**
     * Native custom getter for the property.
     */
    get?: PropertyDescriptor['get'];
    /**
     * Native custom setter for the property.
     */
    set?: PropertyDescriptor['set'];
    /**
     * Define custom getter for the property.
     * @param value The current property value.
     */
    getter?: (value?: T[P]) => ReturnType<NonNullable<PropertyDescriptor['get']>>;
    /**
     * Define a custom setter for the property.
     * It runs before property validations.
     * The returned value will be set to the property.
     * @param newValue The value to set.
     */
    setter?: (newValue?: Parameters<NonNullable<PropertyDescriptor['set']>>[0]) => T[P];
    /**
     * The initializer function.
     */
    initializer?: Function;
};
/**
 * Retrieve all properties descriptors.
 * @param prototype The component prototype.
 * @param chain Should create inheritance chain of properties.
 * @returns A list of property descriptors.
 */
export declare const getProperties: <T extends ComponentInstance<HTMLElement>>(prototype: WithProperties<T>, chain?: boolean) => PropertiesOf<T>;
/**
 * Retrieve property declaration.
 * @param prototype The component prototype.
 * @param propertyKey The name of the property.
 * @param failIfMissing Should throw an exception if the property is not defined.
 * @returns The property declaration.
 * @throws If the property is not defined and `failIfMissing` is `true`.
 */
export declare const getProperty: <T extends ComponentInstance<HTMLElement>, P extends keyof T>(prototype: T, propertyKey: P, failIfMissing?: boolean) => PropertiesOf<T>[P];
/**
 * Define an observed property.
 * @param prototype The component prototype.
 * @param propertyKey The name of the property.
 * @param declaration The property descriptor.
 * @param symbolKey The symbol to use to store property value.
 * @param isStatic The property definition is static.
 * @returns The final descriptor.
 */
export declare const defineProperty: <T extends ComponentInstance<HTMLElement>, P extends keyof T>(prototype: WithProperties<T>, propertyKey: P, declaration: PropertyDeclaration<Constructor<T[P]>>, symbolKey: symbol, isStatic?: boolean) => PropertyDescriptor;
/**
 * Define component constructor properties.
 * @param prototype The component prototype.
 */
export declare const defineProperties: <T extends ComponentInstance<HTMLElement>>(prototype: T) => void;
/**
 * Get the property bound to the attribute.
 * @param prototype The prototype of the Component.
 * @param attributeName The name of the bound attribute.
 * @returns The property declaration.
 */
export declare const getPropertyForAttribute: <T extends ComponentInstance<HTMLElement>>(prototype: T, attributeName: string) => PropertiesOf<T>[Extract<keyof T, string>] | null;
/**
 * Reflect property value to attribute.
 *
 * @param element The node to update.
 * @param propertyName The name of the changed property.
 * @param newValue The new value for the property (undefined if removed).
 */
export declare const reflectPropertyToAttribute: <T extends ComponentInstance<HTMLElement>, P extends keyof T>(element: T, propertyName: P, newValue: T[P]) => void;
/**
 * Reflect attribute value to property.
 *
 * @param element The node to update.
 * @param attributeName The name of the changed attribute.
 * @param newValue The new value of the attribute (null if removed).
 */
export declare const reflectAttributeToProperty: <T extends ComponentInstance<HTMLElement>>(element: T, attributeName: string, newValue: string | null) => void;
/**
 * Add a property to a component prototype.
 * @param targetOrClassElement The component prototype.
 * @param declaration The property declaration.
 * @param propertyKey The property name.
 * @param descriptor The native property descriptor.
 * @returns The property descriptor.
 */
export declare const createProperty: <T extends ComponentInstance<HTMLElement>, P extends keyof T>(targetOrClassElement: T, declaration: PropertyDeclaration<Constructor<T[P]>>, propertyKey?: P | undefined, descriptor?: PropertyDeclaration<Constructor<T[P]>> | undefined) => any;
/**
 * Add a property observer to a component prototype.
 * @param targetOrClassElement The component prototype.
 * @param propertyKey The property name to watch.
 * @param methodKey The method name.
 * @returns The observer descriptor.
 */
export declare const createObserver: <T extends ComponentInstance<HTMLElement>, P extends keyof T, M extends keyof T>(targetOrClassElement: T, propertyKey: P, methodKey?: M | undefined) => any;
/**
 * Get element properties observers.
 * @param element The node.
 * @returns The map of observers.
 */
export declare const getObservers: <T extends ComponentInstance<HTMLElement>>(element: WithObservers<T>) => ObserversOf<T>;
/**
 * Get observers for an element property.
 * @param element The node.
 * @param propertyName The name of the property.
 * @returns A list of observers.
 * @throws If the property is not defined.
 */
export declare const getPropertyObservers: <T extends ComponentInstance<HTMLElement>, P extends keyof T>(element: T, propertyName: P) => ObserversOf<T>[P];
/**
 * Add an observer for a property.
 * @param element The node context.
 * @param propertyName The name of the property to watch.
 * @param observer The observer function to add.
 */
export declare const addObserver: <T extends ComponentInstance<HTMLElement>, P extends keyof T>(element: WithObservers<T>, propertyName: P, observer: PropertyObserver<T[P]>) => void;
/**
 * Remove an observer for a property.
 * @param element The node context.
 * @param propertyName The name of the watched property.
 * @param observer The observer function to remove.
 */
export declare const removeObserver: <T extends ComponentInstance<HTMLElement>, P extends keyof T>(element: WithObservers<T>, propertyName: P, observer: PropertyObserver<T[P]>) => void;
/**
 * A decorator for property definition.
 * @param declaration The property declaration.
 * @returns The decorator initializer.
 */
export declare function property<TypeConstructorHint extends Constructor<unknown> = Constructor<unknown>>(declaration?: PropertyDeclaration<TypeConstructorHint>): <T extends ComponentInstance<HTMLElement>, P extends keyof T>(targetOrClassElement: T, propertyKey?: P | undefined, descriptor?: PropertyDeclaration<Constructor<T[P]>> | undefined) => any;
/**
 * A decorator for state property definition.
 * @param declaration The state property declaration.
 * @returns The decorator initializer.
 */
export declare function state<TypeConstructorHint extends Constructor<unknown> = Constructor<unknown>>(declaration?: PropertyDeclaration<TypeConstructorHint>): <T extends ComponentInstance<HTMLElement>, P extends keyof T>(targetOrClassElement: T, propertyKey?: P | undefined, descriptor?: PropertyDeclaration<Constructor<T[P]>> | undefined) => any;
/**
 * A decorator for property observer.
 *
 * @param propertyKey The property key to observe.
 * @returns The decorator initializer.
 */
export declare function observe(propertyKey: string): Function;
export {};
