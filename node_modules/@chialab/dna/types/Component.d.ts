import type { Constructor, ClassDescriptor } from './helpers';
import type { CustomElement, CustomElementConstructor } from './CustomElementRegistry';
import type { DelegatedEventCallback, ListenerConfig } from './events';
import type { PropertyConfig, PropertyObserver } from './property';
import type { Template } from './JSX';
/**
 * A symbol which identify components.
 */
export declare const COMPONENT_SYMBOL: unique symbol;
/**
 * A symbol which identify emulated components.
 */
export declare const EMULATE_LIFECYCLE_SYMBOL: unique symbol;
/**
 * An augmented node with component flags.
 */
export type WithComponentFlags<T> = T & {
    [COMPONENT_SYMBOL]?: boolean;
    [EMULATE_LIFECYCLE_SYMBOL]?: boolean;
};
/**
 * The component mixin interface.
 */
export interface ComponentMixin {
    /**
     * A set of watched properties.
     */
    readonly watchedProperties: PropertyKey[];
    /**
     * A flag with the connected value of the node.
     */
    get isConnected(): boolean;
    /**
     * A list of slot nodes.
     */
    get slotChildNodes(): Node[] | undefined;
    /**
     * Initialize component properties.
     * @deprecated
     */
    initialize(): void;
    /**
     * Invoked each time one of a Component's state property is setted, removed, or changed.
     *
     * @param propertyName The name of the changed property.
     * @param oldValue The previous value of the property.
     * @param newValue The new value for the property (undefined if removed).
     */
    stateChangedCallback<P extends keyof Members<this>>(propertyName: P, oldValue: this[P] | undefined, newValue: this[P]): void;
    /**
     * Invoked each time one of a Component's property is setted, removed, or changed.
     *
     * @param propertyName The name of the changed property.
     * @param oldValue The previous value of the property.
     * @param newValue The new value for the property (undefined if removed).
     */
    propertyChangedCallback<P extends keyof Members<this>>(propertyName: P, oldValue: this[P] | undefined, newValue: this[P]): void;
    /**
     * Get the inner value of a property.
     * This is an helper method for properties getters and setters.
     * @param propertyName The name of the property to get.
     * @returns The inner value of the property.
     */
    getInnerPropertyValue<P extends keyof Members<this>>(propertyName: P): this[P];
    /**
     * Set the inner value of a property.
     * This is an helper method for properties getters and setters.
     * @param propertyName The name of the property to get.
     * @param value The inner value to set.
     */
    setInnerPropertyValue<P extends keyof Members<this>>(propertyName: P, value: this[P]): void;
    /**
     * Observe a Component Property.
     *
     * @param propertyName The name of the Property to observe
     * @param observer The callback function
     */
    observe<P extends keyof Members<this>>(propertyName: P, observer: PropertyObserver<this[P]>): void;
    /**
     * Unobserve a Component Property.
     *
     * @param propertyName The name of the Property to unobserve
     * @param observer The callback function to remove
     */
    unobserve<P extends keyof Members<this>>(propertyName: P, observer: PropertyObserver<this[P]>): void;
    /**
     * Dispatch a custom Event.
     *
     * @param event The event to dispatch or the name of the synthetic event to create.
     * @param detail Detail object of the event.
     * @param bubbles Should the event bubble.
     * @param cancelable Should the event be cancelable.
     * @param composed Is the event composed.
     */
    dispatchEvent(event: Event): boolean;
    dispatchEvent(event: string, detail?: CustomEventInit['detail'], bubbles?: boolean, cancelable?: boolean, composed?: boolean): boolean;
    /**
     * Dispatch an async custom Event.
     *
     * @param event The event to dispatch or the name of the synthetic event to create.
     * @param detail Detail object of the event.
     * @param bubbles Should the event bubble.
     * @param cancelable Should the event be cancelable.
     * @param composed Is the event composed.
     */
    dispatchAsyncEvent(event: Event): Promise<any[]>;
    dispatchAsyncEvent(event: string, detail?: CustomEventInit['detail'], bubbles?: boolean, cancelable?: boolean, composed?: boolean): Promise<any[]>;
    /**
     * Delegate an Event listener.
     *
     * @param eventName The event name to listen
     * @param selector The selector to delegate
     * @param callback The callback to trigger when an Event matches the delegation
     */
    delegateEventListener(event: string, selector: string | null, callback: DelegatedEventCallback, options?: AddEventListenerOptions): void;
    /**
     * Remove an Event delegation.
     *
     * @param eventName The Event name to undelegate
     * @param selector The selector to undelegate
     * @param callback The callback to remove
     */
    undelegateEventListener(event: string, selector: string | null, callback: DelegatedEventCallback): void;
    /**
     * Render method of the Component.
     *
     * @returns The instances of the rendered Components and/or Nodes
     */
    render(): Template | undefined;
    /**
     * Force an element to re-render.
     */
    forceUpdate(): void;
}
/**
 * The basic DNA Component interface.
 * It's a Custom Element, but with some extra useful method.
 * @see [W3C specification]{@link https://w3c.github.io/webcomponents/spec/custom/}.
 */
export type ComponentInstance<T extends HTMLElement = HTMLElement> = CustomElement<T> & ComponentMixin;
/**
 * Component prototype keys.
 */
export type PrototypeKeys = keyof CustomElement | keyof ComponentMixin;
/**
 * Get all methods of a class, excluding inherited methods.
 */
export type MethodsOf<T> = Exclude<{
    [K in keyof T]: T[K] extends Function ? K : never;
}[keyof T], never & PrototypeKeys>;
/**
 * Check if a property is flagged as readonly.
 */
export type IsReadonly<T, K extends keyof T> = (<C>() => C extends {
    [Q in K]: T[K];
} ? 1 : 2) extends (<C>() => C extends {
    -readonly [Q in K]: T[K];
} ? 1 : 2) ? never : K;
/**
 * Get all members of a class, excluding inherited members.
 */
export type Members<T> = {
    [K in keyof T]?: K extends PrototypeKeys ? never : K extends IsReadonly<T, K> ? never : T[K];
};
/**
 * Get all members names of a class, excluding inherited members.
 */
export type MemberKeys<T> = Exclude<{
    [K in keyof T]?: K extends PrototypeKeys ? never : K extends IsReadonly<T, K> ? never : K;
}[keyof T], never | undefined>;
/**
 * Get a filtered list of available members of a class, excluding inherited members.
 */
export type Props<T> = Partial<Pick<Members<T>, MemberKeys<T>>>;
/**
 * The basic DNA Component constructor.
 */
export interface ComponentConstructor<T extends ComponentInstance = ComponentInstance> extends CustomElementConstructor<T> {
    /**
     * Define component properties.
     */
    readonly properties?: {
        [key: string]: PropertyConfig;
    };
    /**
     * Define component listeners.
     */
    readonly listeners?: {
        [key: string]: ListenerConfig;
    };
    /**
     * Identify shimmed constructors.
     * Constructor will skip native constructing when true.
     */
    shim?: boolean;
    /**
     * Upgrade a plain element prototype.
     * @param node The node to upgrade.
     * @returns The new prototyped node.
     */
    upgrade(node: HTMLElement): T;
    /**
     * Create a new Component instance.
     * @param node Instantiate the element using the given node instead of creating a new one.
     * @param properties A set of initial properties for the element.
     */
    new (node?: HTMLElement, properties?: {
        [key: string]: any;
    }): T;
    new (properties?: {
        [key: string]: any;
    }): T;
    prototype: T;
}
/**
 * Check if a node is a component.
 * @param node The node to check.
 * @returns True if element is a custom element.
 */
export declare const isComponent: <T extends ComponentInstance<HTMLElement>>(node: Node | T) => node is T;
/**
 * Check if a constructor is a component constructor.
 * @param constructor The constructor to check.
 * @returns True if the constructor is a component class.
 */
export declare const isComponentConstructor: <T extends ComponentInstance<HTMLElement>, C extends ComponentConstructor<T>>(constructor: Function | C) => constructor is C;
/**
 * Flag the element for life cycle emulation.
 * @param node The element to flag.
 */
export declare const emulateLifeCycle: (node: WithComponentFlags<HTMLElement>) => void;
/**
 * Life cycle emulation status.
 * @returns True if life cycle emulation is enabled.
 */
export declare const emulatingLifeCycle: () => boolean;
/**
 * Check if a node require emulated life cycle.
 * @param node The node to check.
 * @returns The node require emulated life cycle.
 */
export declare const shouldEmulateLifeCycle: <T extends HTMLElement>(node: WithComponentFlags<Element | T>) => node is ComponentInstance<T>;
/**
 * Invoke `connectedCallback` method of a Node (and its descendents).
 * It does nothing if life cycle is disabled.
 *
 * @param node The connected node.
 */
export declare const connect: (node: Node) => void;
/**
 * Invoke `disconnectedCallback` method of a Node (and its descendents).
 * It does nothing if life cycle is disabled.
 *
 * @param node The disconnected node.
 */
export declare const disconnect: (node: Node) => void;
/**
 * Create a shim Constructor for Element constructors, in order to extend and instantiate them programmatically,
 * because using `new HTMLElement()` in browsers throw `Illegal constructor`.
 *
 * @param base The constructor or the class to shim.
 * @returns A newable constructor with the same prototype.
 */
export declare const shim: <T extends {
    new (): HTMLElement;
    prototype: HTMLElement;
}>(base: T) => T;
/**
 * Get a native HTMLElement constructor to extend by its name.
 * @param constructor The constructor (eg. "HTMLAnchorElement") to extend.
 * @returns A proxy that extends the native constructor.
 */
export declare const extend: <T extends HTMLElement>(constructor: Constructor<T>) => ComponentConstructor<ComponentInstance<T>>;
/**
 * The DNA base Component constructor, a Custom Element constructor with
 * declarative properties and event delegations, custom template and
 * a complete life cycle implementation.
 * All DNA components **must** extends this class.
 */
export declare const Component: ComponentConstructor<ComponentInstance<HTMLElement>>;
/**
 * Decorate a component prototype class.
 * @param classOrDescriptor The component class to decorate.
 * @returns The decorated component class.
 */
export declare const customElementPrototype: <T extends ComponentConstructor<ComponentInstance<HTMLElement>>>(classOrDescriptor: ClassDescriptor | T) => any;
/**
 * Decorate and define a component class.
 * @param name The name of the custom element.
 * @param options The custom element options.
 * @returns The decorated component class.
 */
export declare const customElement: (name: string, options?: ElementDefinitionOptions) => <T extends ComponentConstructor<ComponentInstance<HTMLElement>>>(classOrDescriptor: ClassDescriptor | T) => any;
